<?php
/**
 * ElasticSyncApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * ElasticSyncApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ElasticSyncApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restElasticSyncMappingCsvRowsSyncIdGet' => [
            'application/json',
        ],
        'restElasticSyncMappingFieldsSyncTypeGet' => [
            'application/json',
        ],
        'restElasticSyncMappingFilterLabelsGet' => [
            'application/json',
        ],
        'restElasticSyncMappingMapCsvColumnsSyncIdGet' => [
            'application/json',
        ],
        'restElasticSyncMappingMapTreeGet' => [
            'application/json',
        ],
        'restElasticSyncMappingModelSyncTypeGet' => [
            'application/json',
        ],
        'restElasticSyncMappingValuesSyncTypeGet' => [
            'application/json',
        ],
        'restElasticSyncMappingVariationGet' => [
            'application/json',
        ],
        'restElasticSyncSyncChangeCsvPut' => [
            'application/json',
        ],
        'restElasticSyncSyncImportDifferentPost' => [
            'application/json',
        ],
        'restElasticSyncSyncImportFilePublicUrlDifferentPost' => [
            'application/json',
        ],
        'restElasticSyncSyncImportFilePublicUrlPost' => [
            'application/json',
        ],
        'restElasticSyncSyncImportPost' => [
            'application/json',
        ],
        'restElasticSyncSyncIntervalsGet' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingFilterFilterIdDelete' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingFilterFilterIdGet' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingFilterFilterIdPut' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdDelete' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdFilterPost' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdFiltersGet' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdFiltersPost' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdFiltersPut' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdGet' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdPut' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdRowPost' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdRowsGet' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdRowsPost' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingMappingIdRowsPut' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingRowRowIdDelete' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingRowRowIdGet' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingRowRowIdPut' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingsCopyPost' => [
            'application/json',
        ],
        'restElasticSyncSyncMappingsDelete' => [
            'application/json',
        ],
        'restElasticSyncSyncMatchingDecimalsGet' => [
            'application/json',
        ],
        'restElasticSyncSyncMatchingMatchingIdDelete' => [
            'application/json',
        ],
        'restElasticSyncSyncMatchingMatchingIdGet' => [
            'application/json',
        ],
        'restElasticSyncSyncMatchingMatchingIdPut' => [
            'application/json',
        ],
        'restElasticSyncSyncOptionOptionIdDelete' => [
            'application/json',
        ],
        'restElasticSyncSyncOptionOptionIdGet' => [
            'application/json',
        ],
        'restElasticSyncSyncOptionOptionIdPut' => [
            'application/json',
        ],
        'restElasticSyncSyncPost' => [
            'application/json',
        ],
        'restElasticSyncSyncReportIdGet' => [
            'application/json',
        ],
        'restElasticSyncSyncReportsAvailabilityGet' => [
            'application/json',
        ],
        'restElasticSyncSyncReportsGet' => [
            'application/json',
        ],
        'restElasticSyncSyncResetCacheGet' => [
            'application/json',
        ],
        'restElasticSyncSyncScheduleTimesGet' => [
            'application/json',
        ],
        'restElasticSyncSyncStatusGet' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdDelete' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdGet' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdMappingPost' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdMappingsGet' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdMatchesGet' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdMatchesPost' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdMatchesPut' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdMatchingEntityGet' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdMatchingPost' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdOptionPost' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdOptionsGet' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdOptionsPost' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdOptionsPut' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdPreviewValuesGet' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdPut' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdRunPost' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncIdSourcePreviewGet' => [
            'application/json',
        ],
        'restElasticSyncSyncSyncTypeMatchingFieldsGet' => [
            'application/json',
        ],
        'restElasticSyncSyncTypesGet' => [
            'application/json',
        ],
        'restElasticSyncSyncsCopyPost' => [
            'application/json',
        ],
        'restElasticSyncSyncsDelete' => [
            'application/json',
        ],
        'restElasticSyncSyncsExportPost' => [
            'application/json',
        ],
        'restElasticSyncSyncsExportSyncIdGet' => [
            'application/json',
        ],
        'restElasticSyncSyncsGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restElasticSyncMappingCsvRowsSyncIdGet
     *
     * Get the csv rows.
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncMappingCsvRowsSyncIdGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncMappingCsvRowsSyncIdGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncMappingCsvRowsSyncIdGetWithHttpInfo
     *
     * Get the csv rows.
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncMappingCsvRowsSyncIdGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncMappingCsvRowsSyncIdGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncMappingCsvRowsSyncIdGetAsync
     *
     * Get the csv rows.
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingCsvRowsSyncIdGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncMappingCsvRowsSyncIdGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncMappingCsvRowsSyncIdGetAsyncWithHttpInfo
     *
     * Get the csv rows.
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingCsvRowsSyncIdGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncMappingCsvRowsSyncIdGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncMappingCsvRowsSyncIdGet'
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncMappingCsvRowsSyncIdGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingCsvRowsSyncIdGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncMappingCsvRowsSyncIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/mapping/csv-rows/{syncId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncMappingFieldsSyncTypeGet
     *
     * Get the plenty fields value map for a particular sync type.
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncMappingFieldsSyncTypeGet(
        string $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncMappingFieldsSyncTypeGetWithHttpInfo($sync_type, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncMappingFieldsSyncTypeGetWithHttpInfo
     *
     * Get the plenty fields value map for a particular sync type.
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncMappingFieldsSyncTypeGetWithHttpInfo(
        string $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'][0]
    ): array
    {
        $request = $this->restElasticSyncMappingFieldsSyncTypeGetRequest($sync_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncMappingFieldsSyncTypeGetAsync
     *
     * Get the plenty fields value map for a particular sync type.
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingFieldsSyncTypeGetAsync(
        string $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncMappingFieldsSyncTypeGetAsyncWithHttpInfo($sync_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncMappingFieldsSyncTypeGetAsyncWithHttpInfo
     *
     * Get the plenty fields value map for a particular sync type.
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingFieldsSyncTypeGetAsyncWithHttpInfo(
        $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncMappingFieldsSyncTypeGetRequest($sync_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncMappingFieldsSyncTypeGet'
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncMappingFieldsSyncTypeGetRequest(
        $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingFieldsSyncTypeGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_type' is set
        if ($sync_type === null || (is_array($sync_type) && count($sync_type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_type when calling restElasticSyncMappingFieldsSyncTypeGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/mapping/fields/{syncType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_type !== null) {
            $resourcePath = str_replace(
                '{' . 'syncType' . '}',
                ObjectSerializer::toPathValue($sync_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncMappingFilterLabelsGet
     *
     * Get the label list for mapping filtration.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFilterLabelsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncMappingFilterLabelsGet(
        string $contentType = self::contentTypes['restElasticSyncMappingFilterLabelsGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncMappingFilterLabelsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncMappingFilterLabelsGetWithHttpInfo
     *
     * Get the label list for mapping filtration.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFilterLabelsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncMappingFilterLabelsGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncMappingFilterLabelsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncMappingFilterLabelsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncMappingFilterLabelsGetAsync
     *
     * Get the label list for mapping filtration.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFilterLabelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingFilterLabelsGetAsync(
        string $contentType = self::contentTypes['restElasticSyncMappingFilterLabelsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncMappingFilterLabelsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncMappingFilterLabelsGetAsyncWithHttpInfo
     *
     * Get the label list for mapping filtration.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFilterLabelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingFilterLabelsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncMappingFilterLabelsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncMappingFilterLabelsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncMappingFilterLabelsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingFilterLabelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncMappingFilterLabelsGetRequest(
        string $contentType = self::contentTypes['restElasticSyncMappingFilterLabelsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/mapping/filter/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncMappingMapCsvColumnsSyncIdGet
     *
     * Get the csv columns of a sync.
     *
     * @param  int $sync_id The sync id of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncMappingMapCsvColumnsSyncIdGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncMappingMapCsvColumnsSyncIdGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncMappingMapCsvColumnsSyncIdGetWithHttpInfo
     *
     * Get the csv columns of a sync.
     *
     * @param  int $sync_id The sync id of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncMappingMapCsvColumnsSyncIdGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncMappingMapCsvColumnsSyncIdGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncMappingMapCsvColumnsSyncIdGetAsync
     *
     * Get the csv columns of a sync.
     *
     * @param  int $sync_id The sync id of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingMapCsvColumnsSyncIdGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncMappingMapCsvColumnsSyncIdGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncMappingMapCsvColumnsSyncIdGetAsyncWithHttpInfo
     *
     * Get the csv columns of a sync.
     *
     * @param  int $sync_id The sync id of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingMapCsvColumnsSyncIdGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncMappingMapCsvColumnsSyncIdGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncMappingMapCsvColumnsSyncIdGet'
     *
     * @param  int $sync_id The sync id of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncMappingMapCsvColumnsSyncIdGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncMappingMapCsvColumnsSyncIdGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncMappingMapCsvColumnsSyncIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/mapping/map/csv-columns/{syncId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncMappingMapTreeGet
     *
     * Get the mapping values tree.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapTreeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncMappingMapTreeGet(
        string $contentType = self::contentTypes['restElasticSyncMappingMapTreeGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncMappingMapTreeGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncMappingMapTreeGetWithHttpInfo
     *
     * Get the mapping values tree.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapTreeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncMappingMapTreeGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncMappingMapTreeGet'][0]
    ): array
    {
        $request = $this->restElasticSyncMappingMapTreeGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncMappingMapTreeGetAsync
     *
     * Get the mapping values tree.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapTreeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingMapTreeGetAsync(
        string $contentType = self::contentTypes['restElasticSyncMappingMapTreeGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncMappingMapTreeGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncMappingMapTreeGetAsyncWithHttpInfo
     *
     * Get the mapping values tree.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapTreeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingMapTreeGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncMappingMapTreeGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncMappingMapTreeGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncMappingMapTreeGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingMapTreeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncMappingMapTreeGetRequest(
        string $contentType = self::contentTypes['restElasticSyncMappingMapTreeGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/mapping/map/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncMappingModelSyncTypeGet
     *
     * Get the model key to field value key.
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingModelSyncTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncMappingModelSyncTypeGet(
        string $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingModelSyncTypeGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncMappingModelSyncTypeGetWithHttpInfo($sync_type, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncMappingModelSyncTypeGetWithHttpInfo
     *
     * Get the model key to field value key.
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingModelSyncTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncMappingModelSyncTypeGetWithHttpInfo(
        string $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingModelSyncTypeGet'][0]
    ): array
    {
        $request = $this->restElasticSyncMappingModelSyncTypeGetRequest($sync_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncMappingModelSyncTypeGetAsync
     *
     * Get the model key to field value key.
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingModelSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingModelSyncTypeGetAsync(
        string $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingModelSyncTypeGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncMappingModelSyncTypeGetAsyncWithHttpInfo($sync_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncMappingModelSyncTypeGetAsyncWithHttpInfo
     *
     * Get the model key to field value key.
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingModelSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingModelSyncTypeGetAsyncWithHttpInfo(
        $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingModelSyncTypeGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncMappingModelSyncTypeGetRequest($sync_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncMappingModelSyncTypeGet'
     *
     * @param  string $sync_type The sync type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingModelSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncMappingModelSyncTypeGetRequest(
        $sync_type,
        string $contentType = self::contentTypes['restElasticSyncMappingModelSyncTypeGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_type' is set
        if ($sync_type === null || (is_array($sync_type) && count($sync_type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_type when calling restElasticSyncMappingModelSyncTypeGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/mapping/model/{syncType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_type !== null) {
            $resourcePath = str_replace(
                '{' . 'syncType' . '}',
                ObjectSerializer::toPathValue($sync_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncMappingValuesSyncTypeGet
     *
     * Get the mapping values.
     *
     * @param  string $sync_type The sync type (required)
     * @param  int $sync_type2 sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncMappingValuesSyncTypeGet(
        string $sync_type,
        int $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncMappingValuesSyncTypeGetWithHttpInfo($sync_type, $sync_type2, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncMappingValuesSyncTypeGetWithHttpInfo
     *
     * Get the mapping values.
     *
     * @param  string $sync_type The sync type (required)
     * @param  int $sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncMappingValuesSyncTypeGetWithHttpInfo(
        string $sync_type,
        int $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'][0]
    ): array
    {
        $request = $this->restElasticSyncMappingValuesSyncTypeGetRequest($sync_type, $sync_type2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncMappingValuesSyncTypeGetAsync
     *
     * Get the mapping values.
     *
     * @param  string $sync_type The sync type (required)
     * @param  int $sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingValuesSyncTypeGetAsync(
        string $sync_type,
        int $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncMappingValuesSyncTypeGetAsyncWithHttpInfo($sync_type, $sync_type2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncMappingValuesSyncTypeGetAsyncWithHttpInfo
     *
     * Get the mapping values.
     *
     * @param  string $sync_type The sync type (required)
     * @param  int $sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingValuesSyncTypeGetAsyncWithHttpInfo(
        $sync_type,
        $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncMappingValuesSyncTypeGetRequest($sync_type, $sync_type2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncMappingValuesSyncTypeGet'
     *
     * @param  string $sync_type The sync type (required)
     * @param  int $sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncMappingValuesSyncTypeGetRequest(
        $sync_type,
        $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncMappingValuesSyncTypeGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_type' is set
        if ($sync_type === null || (is_array($sync_type) && count($sync_type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_type when calling restElasticSyncMappingValuesSyncTypeGet'
            );
        }

        // verify the required parameter 'sync_type2' is set
        if ($sync_type2 === null || (is_array($sync_type2) && count($sync_type2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_type2 when calling restElasticSyncMappingValuesSyncTypeGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/mapping/values/{syncType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sync_type,
            'sync_type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($sync_type2 !== null) {
            $resourcePath = str_replace(
                '{' . 'syncType' . '}',
                ObjectSerializer::toPathValue($sync_type2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncMappingVariationGet
     *
     * Get a list with variation matches.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingVariationGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncMappingVariationGet(
        string $contentType = self::contentTypes['restElasticSyncMappingVariationGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncMappingVariationGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncMappingVariationGetWithHttpInfo
     *
     * Get a list with variation matches.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingVariationGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncMappingVariationGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncMappingVariationGet'][0]
    ): array
    {
        $request = $this->restElasticSyncMappingVariationGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncMappingVariationGetAsync
     *
     * Get a list with variation matches.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingVariationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingVariationGetAsync(
        string $contentType = self::contentTypes['restElasticSyncMappingVariationGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncMappingVariationGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncMappingVariationGetAsyncWithHttpInfo
     *
     * Get a list with variation matches.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingVariationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncMappingVariationGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncMappingVariationGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncMappingVariationGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncMappingVariationGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncMappingVariationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncMappingVariationGetRequest(
        string $contentType = self::contentTypes['restElasticSyncMappingVariationGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/mapping/variation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncChangeCsvPut
     *
     * Update the Csv of a Sync.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncChangeCsvPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncChangeCsvPut(
        string $contentType = self::contentTypes['restElasticSyncSyncChangeCsvPut'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncChangeCsvPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncChangeCsvPutWithHttpInfo
     *
     * Update the Csv of a Sync.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncChangeCsvPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncChangeCsvPutWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncChangeCsvPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncChangeCsvPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncChangeCsvPutAsync
     *
     * Update the Csv of a Sync.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncChangeCsvPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncChangeCsvPutAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncChangeCsvPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncChangeCsvPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncChangeCsvPutAsyncWithHttpInfo
     *
     * Update the Csv of a Sync.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncChangeCsvPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncChangeCsvPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncChangeCsvPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncChangeCsvPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncChangeCsvPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncChangeCsvPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncChangeCsvPutRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncChangeCsvPut'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/change-csv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncImportDifferentPost
     *
     * Import the sync with different plentyId.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportDifferentPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restElasticSyncSyncImportDifferentPost(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportDifferentPost'][0]
    ): void
    {
        $this->restElasticSyncSyncImportDifferentPostWithHttpInfo($file, $contentType);
    }

    /**
     * Operation restElasticSyncSyncImportDifferentPostWithHttpInfo
     *
     * Import the sync with different plentyId.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportDifferentPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncImportDifferentPostWithHttpInfo(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportDifferentPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncImportDifferentPostRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncImportDifferentPostAsync
     *
     * Import the sync with different plentyId.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportDifferentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncImportDifferentPostAsync(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportDifferentPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncImportDifferentPostAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncImportDifferentPostAsyncWithHttpInfo
     *
     * Import the sync with different plentyId.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportDifferentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncImportDifferentPostAsyncWithHttpInfo(
        $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportDifferentPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restElasticSyncSyncImportDifferentPostRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncImportDifferentPost'
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportDifferentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncImportDifferentPostRequest(
        $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportDifferentPost'][0]
    ): Request
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file when calling restElasticSyncSyncImportDifferentPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/import-different';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncImportFilePublicUrlDifferentPost
     *
     * Import the sync with different plentyId.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restElasticSyncSyncImportFilePublicUrlDifferentPost(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'][0]
    ): void
    {
        $this->restElasticSyncSyncImportFilePublicUrlDifferentPostWithHttpInfo($file, $contentType);
    }

    /**
     * Operation restElasticSyncSyncImportFilePublicUrlDifferentPostWithHttpInfo
     *
     * Import the sync with different plentyId.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncImportFilePublicUrlDifferentPostWithHttpInfo(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncImportFilePublicUrlDifferentPostRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncImportFilePublicUrlDifferentPostAsync
     *
     * Import the sync with different plentyId.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncImportFilePublicUrlDifferentPostAsync(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncImportFilePublicUrlDifferentPostAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncImportFilePublicUrlDifferentPostAsyncWithHttpInfo
     *
     * Import the sync with different plentyId.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncImportFilePublicUrlDifferentPostAsyncWithHttpInfo(
        $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restElasticSyncSyncImportFilePublicUrlDifferentPostRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncImportFilePublicUrlDifferentPost'
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncImportFilePublicUrlDifferentPostRequest(
        $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlDifferentPost'][0]
    ): Request
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file when calling restElasticSyncSyncImportFilePublicUrlDifferentPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/import/file/public-url/different';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncImportFilePublicUrlPost
     *
     * Save the CSV on S3.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restElasticSyncSyncImportFilePublicUrlPost(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'][0]
    ): void
    {
        $this->restElasticSyncSyncImportFilePublicUrlPostWithHttpInfo($file, $contentType);
    }

    /**
     * Operation restElasticSyncSyncImportFilePublicUrlPostWithHttpInfo
     *
     * Save the CSV on S3.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncImportFilePublicUrlPostWithHttpInfo(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncImportFilePublicUrlPostRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncImportFilePublicUrlPostAsync
     *
     * Save the CSV on S3.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncImportFilePublicUrlPostAsync(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncImportFilePublicUrlPostAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncImportFilePublicUrlPostAsyncWithHttpInfo
     *
     * Save the CSV on S3.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncImportFilePublicUrlPostAsyncWithHttpInfo(
        $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restElasticSyncSyncImportFilePublicUrlPostRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncImportFilePublicUrlPost'
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncImportFilePublicUrlPostRequest(
        $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportFilePublicUrlPost'][0]
    ): Request
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file when calling restElasticSyncSyncImportFilePublicUrlPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/import/file/public-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncImportPost
     *
     * Save the CSV on S3.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restElasticSyncSyncImportPost(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportPost'][0]
    ): void
    {
        $this->restElasticSyncSyncImportPostWithHttpInfo($file, $contentType);
    }

    /**
     * Operation restElasticSyncSyncImportPostWithHttpInfo
     *
     * Save the CSV on S3.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncImportPostWithHttpInfo(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncImportPostRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncImportPostAsync
     *
     * Save the CSV on S3.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncImportPostAsync(
        int $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncImportPostAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncImportPostAsyncWithHttpInfo
     *
     * Save the CSV on S3.
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncImportPostAsyncWithHttpInfo(
        $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restElasticSyncSyncImportPostRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncImportPost'
     *
     * @param  int $file The file data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncImportPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncImportPostRequest(
        $file,
        string $contentType = self::contentTypes['restElasticSyncSyncImportPost'][0]
    ): Request
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file when calling restElasticSyncSyncImportPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncIntervalsGet
     *
     * Get list of sync intervals.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncIntervalsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncIntervalsGet(
        string $contentType = self::contentTypes['restElasticSyncSyncIntervalsGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncIntervalsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncIntervalsGetWithHttpInfo
     *
     * Get list of sync intervals.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncIntervalsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncIntervalsGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncIntervalsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncIntervalsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncIntervalsGetAsync
     *
     * Get list of sync intervals.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncIntervalsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncIntervalsGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncIntervalsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncIntervalsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncIntervalsGetAsyncWithHttpInfo
     *
     * Get list of sync intervals.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncIntervalsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncIntervalsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncIntervalsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncIntervalsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncIntervalsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncIntervalsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncIntervalsGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncIntervalsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/intervals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdDelete
     *
     * Delete a sync mapping.
     *
     * @param  int $filter_id filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingFilter
     */
    public function restElasticSyncSyncMappingFilterFilterIdDelete(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'][0]
    ): \ck\Model\ElasticSyncMappingFilter
    {
        list($response) = $this->restElasticSyncSyncMappingFilterFilterIdDeleteWithHttpInfo($filter_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdDeleteWithHttpInfo
     *
     * Delete a sync mapping.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingFilterFilterIdDeleteWithHttpInfo(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingFilterFilterIdDeleteRequest($filter_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingFilter' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdDeleteAsync
     *
     * Delete a sync mapping.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingFilterFilterIdDeleteAsync(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingFilterFilterIdDeleteAsyncWithHttpInfo($filter_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdDeleteAsyncWithHttpInfo
     *
     * Delete a sync mapping.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingFilterFilterIdDeleteAsyncWithHttpInfo(
        $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingFilter';
        $request = $this->restElasticSyncSyncMappingFilterFilterIdDeleteRequest($filter_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingFilterFilterIdDelete'
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingFilterFilterIdDeleteRequest(
        $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'filter_id' is set
        if ($filter_id === null || (is_array($filter_id) && count($filter_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $filter_id when calling restElasticSyncSyncMappingFilterFilterIdDelete'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/filter/{filterId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($filter_id !== null) {
            $resourcePath = str_replace(
                '{' . 'filterId' . '}',
                ObjectSerializer::toPathValue($filter_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdGet
     *
     * Get a sync mapping.
     *
     * @param  int $filter_id filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingFilter
     */
    public function restElasticSyncSyncMappingFilterFilterIdGet(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'][0]
    ): \ck\Model\ElasticSyncMappingFilter
    {
        list($response) = $this->restElasticSyncSyncMappingFilterFilterIdGetWithHttpInfo($filter_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdGetWithHttpInfo
     *
     * Get a sync mapping.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingFilterFilterIdGetWithHttpInfo(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingFilterFilterIdGetRequest($filter_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingFilter' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdGetAsync
     *
     * Get a sync mapping.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingFilterFilterIdGetAsync(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingFilterFilterIdGetAsyncWithHttpInfo($filter_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdGetAsyncWithHttpInfo
     *
     * Get a sync mapping.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingFilterFilterIdGetAsyncWithHttpInfo(
        $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingFilter';
        $request = $this->restElasticSyncSyncMappingFilterFilterIdGetRequest($filter_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingFilterFilterIdGet'
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingFilterFilterIdGetRequest(
        $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdGet'][0]
    ): Request
    {

        // verify the required parameter 'filter_id' is set
        if ($filter_id === null || (is_array($filter_id) && count($filter_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $filter_id when calling restElasticSyncSyncMappingFilterFilterIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/filter/{filterId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($filter_id !== null) {
            $resourcePath = str_replace(
                '{' . 'filterId' . '}',
                ObjectSerializer::toPathValue($filter_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdPut
     *
     * Update a sync mapping filter.
     *
     * @param  int $filter_id filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingFilter
     */
    public function restElasticSyncSyncMappingFilterFilterIdPut(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'][0]
    ): \ck\Model\ElasticSyncMappingFilter
    {
        list($response) = $this->restElasticSyncSyncMappingFilterFilterIdPutWithHttpInfo($filter_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdPutWithHttpInfo
     *
     * Update a sync mapping filter.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingFilterFilterIdPutWithHttpInfo(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingFilterFilterIdPutRequest($filter_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingFilter' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdPutAsync
     *
     * Update a sync mapping filter.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingFilterFilterIdPutAsync(
        int $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingFilterFilterIdPutAsyncWithHttpInfo($filter_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingFilterFilterIdPutAsyncWithHttpInfo
     *
     * Update a sync mapping filter.
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingFilterFilterIdPutAsyncWithHttpInfo(
        $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingFilter';
        $request = $this->restElasticSyncSyncMappingFilterFilterIdPutRequest($filter_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingFilterFilterIdPut'
     *
     * @param  int $filter_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingFilterFilterIdPutRequest(
        $filter_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingFilterFilterIdPut'][0]
    ): Request
    {

        // verify the required parameter 'filter_id' is set
        if ($filter_id === null || (is_array($filter_id) && count($filter_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $filter_id when calling restElasticSyncSyncMappingFilterFilterIdPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/filter/{filterId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($filter_id !== null) {
            $resourcePath = str_replace(
                '{' . 'filterId' . '}',
                ObjectSerializer::toPathValue($filter_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdDelete
     *
     * Delete a sync mapping.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMapping
     */
    public function restElasticSyncSyncMappingMappingIdDelete(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'][0]
    ): \ck\Model\ElasticSyncMapping
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdDeleteWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdDeleteWithHttpInfo
     *
     * Delete a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMapping, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdDeleteWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdDeleteRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMapping' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMapping' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMapping', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMapping';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMapping',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdDeleteAsync
     *
     * Delete a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdDeleteAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdDeleteAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdDeleteAsyncWithHttpInfo
     *
     * Delete a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdDeleteAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMapping';
        $request = $this->restElasticSyncSyncMappingMappingIdDeleteRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdDelete'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdDeleteRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdDelete'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFilterPost
     *
     * Create a sync mapping filter.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingFilter
     */
    public function restElasticSyncSyncMappingMappingIdFilterPost(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'][0]
    ): \ck\Model\ElasticSyncMappingFilter
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdFilterPostWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFilterPostWithHttpInfo
     *
     * Create a sync mapping filter.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdFilterPostWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdFilterPostRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingFilter' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFilterPostAsync
     *
     * Create a sync mapping filter.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdFilterPostAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdFilterPostAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFilterPostAsyncWithHttpInfo
     *
     * Create a sync mapping filter.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdFilterPostAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingFilter';
        $request = $this->restElasticSyncSyncMappingMappingIdFilterPostRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdFilterPost'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdFilterPostRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFilterPost'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdFilterPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}/filter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersGet
     *
     * List sync mappings.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restElasticSyncSyncMappingMappingIdFiltersGet(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'][0]
    ): object
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdFiltersGetWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersGetWithHttpInfo
     *
     * List sync mappings.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdFiltersGetWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdFiltersGetRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersGetAsync
     *
     * List sync mappings.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdFiltersGetAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdFiltersGetAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersGetAsyncWithHttpInfo
     *
     * List sync mappings.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdFiltersGetAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restElasticSyncSyncMappingMappingIdFiltersGetRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdFiltersGet'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdFiltersGetRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersGet'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdFiltersGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}/filters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersPost
     *
     * Create sync mapping filters.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingFilter
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPost(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'][0]
    ): \ck\Model\ElasticSyncMappingFilter
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdFiltersPostWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersPostWithHttpInfo
     *
     * Create sync mapping filters.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPostWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdFiltersPostRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingFilter' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersPostAsync
     *
     * Create sync mapping filters.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPostAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdFiltersPostAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersPostAsyncWithHttpInfo
     *
     * Create sync mapping filters.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPostAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingFilter';
        $request = $this->restElasticSyncSyncMappingMappingIdFiltersPostRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdFiltersPost'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPostRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPost'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdFiltersPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}/filters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersPut
     *
     * Update sync mapping filters.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingFilter
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPut(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'][0]
    ): \ck\Model\ElasticSyncMappingFilter
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdFiltersPutWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersPutWithHttpInfo
     *
     * Update sync mapping filters.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPutWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdFiltersPutRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingFilter' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersPutAsync
     *
     * Update sync mapping filters.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPutAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdFiltersPutAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdFiltersPutAsyncWithHttpInfo
     *
     * Update sync mapping filters.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPutAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingFilter';
        $request = $this->restElasticSyncSyncMappingMappingIdFiltersPutRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdFiltersPut'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdFiltersPutRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdFiltersPut'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdFiltersPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}/filters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdGet
     *
     * Get a sync mapping.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMapping
     */
    public function restElasticSyncSyncMappingMappingIdGet(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdGet'][0]
    ): \ck\Model\ElasticSyncMapping
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdGetWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdGetWithHttpInfo
     *
     * Get a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMapping, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdGetWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdGetRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMapping' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMapping' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMapping', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMapping';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMapping',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdGetAsync
     *
     * Get a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdGetAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdGetAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdGetAsyncWithHttpInfo
     *
     * Get a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdGetAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMapping';
        $request = $this->restElasticSyncSyncMappingMappingIdGetRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdGet'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdGetRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdGet'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdPut
     *
     * Update a sync mapping.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMapping
     */
    public function restElasticSyncSyncMappingMappingIdPut(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdPut'][0]
    ): \ck\Model\ElasticSyncMapping
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdPutWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdPutWithHttpInfo
     *
     * Update a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMapping, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdPutWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdPutRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMapping' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMapping' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMapping', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMapping';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMapping',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdPutAsync
     *
     * Update a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdPutAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdPutAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdPutAsyncWithHttpInfo
     *
     * Update a sync mapping.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdPutAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMapping';
        $request = $this->restElasticSyncSyncMappingMappingIdPutRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdPut'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdPutRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdPut'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowPost
     *
     * Create a sync mapping row.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingRow
     */
    public function restElasticSyncSyncMappingMappingIdRowPost(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'][0]
    ): \ck\Model\ElasticSyncMappingRow
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdRowPostWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowPostWithHttpInfo
     *
     * Create a sync mapping row.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingRow, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdRowPostWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdRowPostRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingRow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingRow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingRow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingRow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingRow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowPostAsync
     *
     * Create a sync mapping row.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdRowPostAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdRowPostAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowPostAsyncWithHttpInfo
     *
     * Create a sync mapping row.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdRowPostAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingRow';
        $request = $this->restElasticSyncSyncMappingMappingIdRowPostRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdRowPost'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdRowPostRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowPost'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdRowPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}/row';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsGet
     *
     * List sync mapping rows.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restElasticSyncSyncMappingMappingIdRowsGet(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'][0]
    ): object
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdRowsGetWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsGetWithHttpInfo
     *
     * List sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdRowsGetWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdRowsGetRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsGetAsync
     *
     * List sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdRowsGetAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdRowsGetAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsGetAsyncWithHttpInfo
     *
     * List sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdRowsGetAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restElasticSyncSyncMappingMappingIdRowsGetRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdRowsGet'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdRowsGetRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsGet'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdRowsGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}/rows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsPost
     *
     * Create sync mapping rows.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingRow
     */
    public function restElasticSyncSyncMappingMappingIdRowsPost(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'][0]
    ): \ck\Model\ElasticSyncMappingRow
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdRowsPostWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsPostWithHttpInfo
     *
     * Create sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingRow, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdRowsPostWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdRowsPostRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingRow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingRow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingRow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingRow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingRow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsPostAsync
     *
     * Create sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdRowsPostAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdRowsPostAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsPostAsyncWithHttpInfo
     *
     * Create sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdRowsPostAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingRow';
        $request = $this->restElasticSyncSyncMappingMappingIdRowsPostRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdRowsPost'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdRowsPostRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPost'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdRowsPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}/rows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsPut
     *
     * Update sync mapping rows.
     *
     * @param  int $mapping_id mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingRow
     */
    public function restElasticSyncSyncMappingMappingIdRowsPut(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'][0]
    ): \ck\Model\ElasticSyncMappingRow
    {
        list($response) = $this->restElasticSyncSyncMappingMappingIdRowsPutWithHttpInfo($mapping_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsPutWithHttpInfo
     *
     * Update sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingRow, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingMappingIdRowsPutWithHttpInfo(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingMappingIdRowsPutRequest($mapping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingRow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingRow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingRow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingRow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingRow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsPutAsync
     *
     * Update sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdRowsPutAsync(
        int $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingMappingIdRowsPutAsyncWithHttpInfo($mapping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingMappingIdRowsPutAsyncWithHttpInfo
     *
     * Update sync mapping rows.
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingMappingIdRowsPutAsyncWithHttpInfo(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingRow';
        $request = $this->restElasticSyncSyncMappingMappingIdRowsPutRequest($mapping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingMappingIdRowsPut'
     *
     * @param  int $mapping_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingMappingIdRowsPutRequest(
        $mapping_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingMappingIdRowsPut'][0]
    ): Request
    {

        // verify the required parameter 'mapping_id' is set
        if ($mapping_id === null || (is_array($mapping_id) && count($mapping_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mapping_id when calling restElasticSyncSyncMappingMappingIdRowsPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/{mappingId}/rows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($mapping_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mappingId' . '}',
                ObjectSerializer::toPathValue($mapping_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdDelete
     *
     * Delete a sync mapping row.
     *
     * @param  int $row_id row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingRow
     */
    public function restElasticSyncSyncMappingRowRowIdDelete(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'][0]
    ): \ck\Model\ElasticSyncMappingRow
    {
        list($response) = $this->restElasticSyncSyncMappingRowRowIdDeleteWithHttpInfo($row_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdDeleteWithHttpInfo
     *
     * Delete a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingRow, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingRowRowIdDeleteWithHttpInfo(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingRowRowIdDeleteRequest($row_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingRow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingRow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingRow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingRow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingRow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdDeleteAsync
     *
     * Delete a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingRowRowIdDeleteAsync(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingRowRowIdDeleteAsyncWithHttpInfo($row_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdDeleteAsyncWithHttpInfo
     *
     * Delete a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingRowRowIdDeleteAsyncWithHttpInfo(
        $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingRow';
        $request = $this->restElasticSyncSyncMappingRowRowIdDeleteRequest($row_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingRowRowIdDelete'
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingRowRowIdDeleteRequest(
        $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'row_id' is set
        if ($row_id === null || (is_array($row_id) && count($row_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $row_id when calling restElasticSyncSyncMappingRowRowIdDelete'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/row/{rowId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($row_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rowId' . '}',
                ObjectSerializer::toPathValue($row_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdGet
     *
     * Get a sync mapping row.
     *
     * @param  int $row_id row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingRow
     */
    public function restElasticSyncSyncMappingRowRowIdGet(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'][0]
    ): \ck\Model\ElasticSyncMappingRow
    {
        list($response) = $this->restElasticSyncSyncMappingRowRowIdGetWithHttpInfo($row_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdGetWithHttpInfo
     *
     * Get a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingRow, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingRowRowIdGetWithHttpInfo(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingRowRowIdGetRequest($row_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingRow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingRow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingRow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingRow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingRow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdGetAsync
     *
     * Get a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingRowRowIdGetAsync(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingRowRowIdGetAsyncWithHttpInfo($row_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdGetAsyncWithHttpInfo
     *
     * Get a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingRowRowIdGetAsyncWithHttpInfo(
        $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingRow';
        $request = $this->restElasticSyncSyncMappingRowRowIdGetRequest($row_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingRowRowIdGet'
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingRowRowIdGetRequest(
        $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdGet'][0]
    ): Request
    {

        // verify the required parameter 'row_id' is set
        if ($row_id === null || (is_array($row_id) && count($row_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $row_id when calling restElasticSyncSyncMappingRowRowIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/row/{rowId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($row_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rowId' . '}',
                ObjectSerializer::toPathValue($row_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdPut
     *
     * Update a sync mapping row.
     *
     * @param  int $row_id row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMappingRow
     */
    public function restElasticSyncSyncMappingRowRowIdPut(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'][0]
    ): \ck\Model\ElasticSyncMappingRow
    {
        list($response) = $this->restElasticSyncSyncMappingRowRowIdPutWithHttpInfo($row_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdPutWithHttpInfo
     *
     * Update a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMappingRow, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingRowRowIdPutWithHttpInfo(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingRowRowIdPutRequest($row_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMappingRow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMappingRow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMappingRow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMappingRow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMappingRow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdPutAsync
     *
     * Update a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingRowRowIdPutAsync(
        int $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingRowRowIdPutAsyncWithHttpInfo($row_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingRowRowIdPutAsyncWithHttpInfo
     *
     * Update a sync mapping row.
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingRowRowIdPutAsyncWithHttpInfo(
        $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMappingRow';
        $request = $this->restElasticSyncSyncMappingRowRowIdPutRequest($row_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingRowRowIdPut'
     *
     * @param  int $row_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingRowRowIdPutRequest(
        $row_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMappingRowRowIdPut'][0]
    ): Request
    {

        // verify the required parameter 'row_id' is set
        if ($row_id === null || (is_array($row_id) && count($row_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $row_id when calling restElasticSyncSyncMappingRowRowIdPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/mapping/row/{rowId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($row_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rowId' . '}',
                ObjectSerializer::toPathValue($row_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingsCopyPost
     *
     * Copy one or more mappings.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsCopyPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncMappingsCopyPost(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsCopyPost'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncMappingsCopyPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMappingsCopyPostWithHttpInfo
     *
     * Copy one or more mappings.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsCopyPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingsCopyPostWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsCopyPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingsCopyPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingsCopyPostAsync
     *
     * Copy one or more mappings.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsCopyPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingsCopyPostAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsCopyPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingsCopyPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingsCopyPostAsyncWithHttpInfo
     *
     * Copy one or more mappings.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsCopyPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingsCopyPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsCopyPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncMappingsCopyPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingsCopyPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsCopyPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingsCopyPostRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsCopyPost'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/mappings/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMappingsDelete
     *
     * Delete one or more mappings.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restElasticSyncSyncMappingsDelete(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsDelete'][0]
    ): void
    {
        $this->restElasticSyncSyncMappingsDeleteWithHttpInfo($contentType);
    }

    /**
     * Operation restElasticSyncSyncMappingsDeleteWithHttpInfo
     *
     * Delete one or more mappings.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMappingsDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsDelete'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMappingsDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMappingsDeleteAsync
     *
     * Delete one or more mappings.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingsDeleteAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsDelete'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMappingsDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMappingsDeleteAsyncWithHttpInfo
     *
     * Delete one or more mappings.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMappingsDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restElasticSyncSyncMappingsDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMappingsDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMappingsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMappingsDeleteRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncMappingsDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/mappings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMatchingDecimalsGet
     *
     * Get list of decimals.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncMatchingDecimalsGet(
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncMatchingDecimalsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMatchingDecimalsGetWithHttpInfo
     *
     * Get list of decimals.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMatchingDecimalsGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMatchingDecimalsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMatchingDecimalsGetAsync
     *
     * Get list of decimals.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMatchingDecimalsGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMatchingDecimalsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMatchingDecimalsGetAsyncWithHttpInfo
     *
     * Get list of decimals.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMatchingDecimalsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncMatchingDecimalsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMatchingDecimalsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMatchingDecimalsGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingDecimalsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/matching/decimals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdDelete
     *
     * Delete a sync matching.
     *
     * @param  int $matching_id matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMatching
     */
    public function restElasticSyncSyncMatchingMatchingIdDelete(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'][0]
    ): \ck\Model\ElasticSyncMatching
    {
        list($response) = $this->restElasticSyncSyncMatchingMatchingIdDeleteWithHttpInfo($matching_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdDeleteWithHttpInfo
     *
     * Delete a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMatching, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMatchingMatchingIdDeleteWithHttpInfo(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMatchingMatchingIdDeleteRequest($matching_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMatching' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMatching' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMatching', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMatching';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMatching',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdDeleteAsync
     *
     * Delete a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMatchingMatchingIdDeleteAsync(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMatchingMatchingIdDeleteAsyncWithHttpInfo($matching_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdDeleteAsyncWithHttpInfo
     *
     * Delete a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMatchingMatchingIdDeleteAsyncWithHttpInfo(
        $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMatching';
        $request = $this->restElasticSyncSyncMatchingMatchingIdDeleteRequest($matching_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMatchingMatchingIdDelete'
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMatchingMatchingIdDeleteRequest(
        $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'matching_id' is set
        if ($matching_id === null || (is_array($matching_id) && count($matching_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $matching_id when calling restElasticSyncSyncMatchingMatchingIdDelete'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/matching/{matchingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($matching_id !== null) {
            $resourcePath = str_replace(
                '{' . 'matchingId' . '}',
                ObjectSerializer::toPathValue($matching_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdGet
     *
     * Get a sync matching.
     *
     * @param  int $matching_id matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMatching
     */
    public function restElasticSyncSyncMatchingMatchingIdGet(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'][0]
    ): \ck\Model\ElasticSyncMatching
    {
        list($response) = $this->restElasticSyncSyncMatchingMatchingIdGetWithHttpInfo($matching_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdGetWithHttpInfo
     *
     * Get a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMatching, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMatchingMatchingIdGetWithHttpInfo(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMatchingMatchingIdGetRequest($matching_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMatching' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMatching' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMatching', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMatching';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMatching',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdGetAsync
     *
     * Get a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMatchingMatchingIdGetAsync(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMatchingMatchingIdGetAsyncWithHttpInfo($matching_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdGetAsyncWithHttpInfo
     *
     * Get a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMatchingMatchingIdGetAsyncWithHttpInfo(
        $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMatching';
        $request = $this->restElasticSyncSyncMatchingMatchingIdGetRequest($matching_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMatchingMatchingIdGet'
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMatchingMatchingIdGetRequest(
        $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdGet'][0]
    ): Request
    {

        // verify the required parameter 'matching_id' is set
        if ($matching_id === null || (is_array($matching_id) && count($matching_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $matching_id when calling restElasticSyncSyncMatchingMatchingIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/matching/{matchingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($matching_id !== null) {
            $resourcePath = str_replace(
                '{' . 'matchingId' . '}',
                ObjectSerializer::toPathValue($matching_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdPut
     *
     * Update a sync matching.
     *
     * @param  int $matching_id matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMatching
     */
    public function restElasticSyncSyncMatchingMatchingIdPut(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'][0]
    ): \ck\Model\ElasticSyncMatching
    {
        list($response) = $this->restElasticSyncSyncMatchingMatchingIdPutWithHttpInfo($matching_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdPutWithHttpInfo
     *
     * Update a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMatching, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncMatchingMatchingIdPutWithHttpInfo(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncMatchingMatchingIdPutRequest($matching_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMatching' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMatching' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMatching', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMatching';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMatching',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdPutAsync
     *
     * Update a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMatchingMatchingIdPutAsync(
        int $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncMatchingMatchingIdPutAsyncWithHttpInfo($matching_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncMatchingMatchingIdPutAsyncWithHttpInfo
     *
     * Update a sync matching.
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncMatchingMatchingIdPutAsyncWithHttpInfo(
        $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMatching';
        $request = $this->restElasticSyncSyncMatchingMatchingIdPutRequest($matching_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncMatchingMatchingIdPut'
     *
     * @param  int $matching_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncMatchingMatchingIdPutRequest(
        $matching_id,
        string $contentType = self::contentTypes['restElasticSyncSyncMatchingMatchingIdPut'][0]
    ): Request
    {

        // verify the required parameter 'matching_id' is set
        if ($matching_id === null || (is_array($matching_id) && count($matching_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $matching_id when calling restElasticSyncSyncMatchingMatchingIdPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/matching/{matchingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($matching_id !== null) {
            $resourcePath = str_replace(
                '{' . 'matchingId' . '}',
                ObjectSerializer::toPathValue($matching_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdDelete
     *
     * Delete a sync.
     *
     * @param  int $option_id option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncOptionOptionIdDelete(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncOptionOptionIdDeleteWithHttpInfo($option_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdDeleteWithHttpInfo
     *
     * Delete a sync.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncOptionOptionIdDeleteWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncOptionOptionIdDeleteRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdDeleteAsync
     *
     * Delete a sync.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncOptionOptionIdDeleteAsync(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncOptionOptionIdDeleteAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete a sync.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncOptionOptionIdDeleteAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncOptionOptionIdDeleteRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncOptionOptionIdDelete'
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncOptionOptionIdDeleteRequest(
        $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restElasticSyncSyncOptionOptionIdDelete'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/option/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdGet
     *
     * Get a sync.
     *
     * @param  int $option_id option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncOptionOptionIdGet(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdGet'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncOptionOptionIdGetWithHttpInfo($option_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdGetWithHttpInfo
     *
     * Get a sync.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncOptionOptionIdGetWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncOptionOptionIdGetRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdGetAsync
     *
     * Get a sync.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncOptionOptionIdGetAsync(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncOptionOptionIdGetAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdGetAsyncWithHttpInfo
     *
     * Get a sync.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncOptionOptionIdGetAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncOptionOptionIdGetRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncOptionOptionIdGet'
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncOptionOptionIdGetRequest(
        $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restElasticSyncSyncOptionOptionIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/option/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdPut
     *
     * Update a sync option.
     *
     * @param  int $option_id option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncOptionOptionIdPut(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdPut'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncOptionOptionIdPutWithHttpInfo($option_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdPutWithHttpInfo
     *
     * Update a sync option.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncOptionOptionIdPutWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncOptionOptionIdPutRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdPutAsync
     *
     * Update a sync option.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncOptionOptionIdPutAsync(
        int $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncOptionOptionIdPutAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncOptionOptionIdPutAsyncWithHttpInfo
     *
     * Update a sync option.
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncOptionOptionIdPutAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncOptionOptionIdPutRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncOptionOptionIdPut'
     *
     * @param  int $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncOptionOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncOptionOptionIdPutRequest(
        $option_id,
        string $contentType = self::contentTypes['restElasticSyncSyncOptionOptionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restElasticSyncSyncOptionOptionIdPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/option/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncPost
     *
     * Create a sync.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncPost(
        string $contentType = self::contentTypes['restElasticSyncSyncPost'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncPostWithHttpInfo
     *
     * Create a sync.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncPostWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncPostAsync
     *
     * Create a sync.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncPostAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncPostAsyncWithHttpInfo
     *
     * Create a sync.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncPostRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncPost'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncReportIdGet
     *
     * Get Log ID
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restElasticSyncSyncReportIdGet(
        int $id,
        string $contentType = self::contentTypes['restElasticSyncSyncReportIdGet'][0]
    ): object
    {
        list($response) = $this->restElasticSyncSyncReportIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncReportIdGetWithHttpInfo
     *
     * Get Log ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncReportIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restElasticSyncSyncReportIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncReportIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncReportIdGetAsync
     *
     * Get Log ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncReportIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restElasticSyncSyncReportIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncReportIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncReportIdGetAsyncWithHttpInfo
     *
     * Get Log ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncReportIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restElasticSyncSyncReportIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restElasticSyncSyncReportIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncReportIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncReportIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restElasticSyncSyncReportIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restElasticSyncSyncReportIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/report/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncReportsAvailabilityGet
     *
     * Check Report Log.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncReportsAvailabilityGet(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncReportsAvailabilityGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncReportsAvailabilityGetWithHttpInfo
     *
     * Check Report Log.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncReportsAvailabilityGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncReportsAvailabilityGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncReportsAvailabilityGetAsync
     *
     * Check Report Log.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncReportsAvailabilityGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncReportsAvailabilityGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncReportsAvailabilityGetAsyncWithHttpInfo
     *
     * Check Report Log.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncReportsAvailabilityGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncReportsAvailabilityGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncReportsAvailabilityGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncReportsAvailabilityGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsAvailabilityGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/reports/availability';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncReportsGet
     *
     * Check Report Log.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
     */
    public function restElasticSyncSyncReportsGet(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsGet'][0]
    ): \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
    {
        list($response) = $this->restElasticSyncSyncReportsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncReportsGetWithHttpInfo
     *
     * Check Report Log.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncReportsGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncReportsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncReportsGetAsync
     *
     * Check Report Log.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncReportsGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncReportsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncReportsGetAsyncWithHttpInfo
     *
     * Check Report Log.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncReportsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
        $request = $this->restElasticSyncSyncReportsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncReportsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncReportsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncReportsGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncReportsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncResetCacheGet
     *
     * Reset the cache.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncResetCacheGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncResetCacheGet(
        string $contentType = self::contentTypes['restElasticSyncSyncResetCacheGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncResetCacheGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncResetCacheGetWithHttpInfo
     *
     * Reset the cache.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncResetCacheGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncResetCacheGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncResetCacheGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncResetCacheGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncResetCacheGetAsync
     *
     * Reset the cache.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncResetCacheGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncResetCacheGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncResetCacheGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncResetCacheGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncResetCacheGetAsyncWithHttpInfo
     *
     * Reset the cache.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncResetCacheGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncResetCacheGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncResetCacheGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncResetCacheGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncResetCacheGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncResetCacheGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncResetCacheGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncResetCacheGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/reset-cache';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncScheduleTimesGet
     *
     * Get schedule times.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncScheduleTimesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restElasticSyncSyncScheduleTimesGet(
        string $contentType = self::contentTypes['restElasticSyncSyncScheduleTimesGet'][0]
    ): object
    {
        list($response) = $this->restElasticSyncSyncScheduleTimesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncScheduleTimesGetWithHttpInfo
     *
     * Get schedule times.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncScheduleTimesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncScheduleTimesGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncScheduleTimesGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncScheduleTimesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncScheduleTimesGetAsync
     *
     * Get schedule times.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncScheduleTimesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncScheduleTimesGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncScheduleTimesGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncScheduleTimesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncScheduleTimesGetAsyncWithHttpInfo
     *
     * Get schedule times.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncScheduleTimesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncScheduleTimesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncScheduleTimesGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restElasticSyncSyncScheduleTimesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncScheduleTimesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncScheduleTimesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncScheduleTimesGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncScheduleTimesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/schedule/times';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncStatusGet
     *
     * Get syncs status.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncStatusGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncStatusGet(
        string $contentType = self::contentTypes['restElasticSyncSyncStatusGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncStatusGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncStatusGetWithHttpInfo
     *
     * Get syncs status.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncStatusGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncStatusGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncStatusGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncStatusGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncStatusGetAsync
     *
     * Get syncs status.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncStatusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncStatusGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncStatusGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncStatusGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncStatusGetAsyncWithHttpInfo
     *
     * Get syncs status.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncStatusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncStatusGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncStatusGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncStatusGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncStatusGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncStatusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncStatusGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncStatusGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdDelete
     *
     * Delete a sync.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncSyncIdDelete(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdDelete'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncSyncIdDeleteWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdDeleteWithHttpInfo
     *
     * Delete a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdDeleteWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdDelete'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdDeleteRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdDeleteAsync
     *
     * Delete a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdDeleteAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdDeleteAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdDeleteAsyncWithHttpInfo
     *
     * Delete a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdDeleteAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncSyncIdDeleteRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdDelete'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdDeleteRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdDelete'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdGet
     *
     * Get a sync.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncSyncIdGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncSyncIdGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdGetWithHttpInfo
     *
     * Get a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdGetAsync
     *
     * Get a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdGetAsyncWithHttpInfo
     *
     * Get a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncSyncIdGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdGet'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMappingPost
     *
     * Create a sync mapping.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMapping
     */
    public function restElasticSyncSyncSyncIdMappingPost(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingPost'][0]
    ): \ck\Model\ElasticSyncMapping
    {
        list($response) = $this->restElasticSyncSyncSyncIdMappingPostWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdMappingPostWithHttpInfo
     *
     * Create a sync mapping.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMapping, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdMappingPostWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdMappingPostRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMapping' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMapping' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMapping', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMapping';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMapping',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdMappingPostAsync
     *
     * Create a sync mapping.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMappingPostAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdMappingPostAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMappingPostAsyncWithHttpInfo
     *
     * Create a sync mapping.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMappingPostAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMapping';
        $request = $this->restElasticSyncSyncSyncIdMappingPostRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdMappingPost'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdMappingPostRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingPost'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdMappingPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/mapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMappingsGet
     *
     * List sync mappings.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
     */
    public function restElasticSyncSyncSyncIdMappingsGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'][0]
    ): \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
    {
        list($response) = $this->restElasticSyncSyncSyncIdMappingsGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdMappingsGetWithHttpInfo
     *
     * List sync mappings.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdMappingsGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdMappingsGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdMappingsGetAsync
     *
     * List sync mappings.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMappingsGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdMappingsGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMappingsGetAsyncWithHttpInfo
     *
     * List sync mappings.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMappingsGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
        $request = $this->restElasticSyncSyncSyncIdMappingsGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdMappingsGet'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdMappingsGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMappingsGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdMappingsGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/mappings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesGet
     *
     * List sync matches.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restElasticSyncSyncSyncIdMatchesGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'][0]
    ): object
    {
        list($response) = $this->restElasticSyncSyncSyncIdMatchesGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesGetWithHttpInfo
     *
     * List sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdMatchesGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdMatchesGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesGetAsync
     *
     * List sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchesGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdMatchesGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesGetAsyncWithHttpInfo
     *
     * List sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchesGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restElasticSyncSyncSyncIdMatchesGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdMatchesGet'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdMatchesGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdMatchesGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/matches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesPost
     *
     * Create sync matches.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMatching
     */
    public function restElasticSyncSyncSyncIdMatchesPost(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'][0]
    ): \ck\Model\ElasticSyncMatching
    {
        list($response) = $this->restElasticSyncSyncSyncIdMatchesPostWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesPostWithHttpInfo
     *
     * Create sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMatching, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdMatchesPostWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdMatchesPostRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMatching' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMatching' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMatching', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMatching';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMatching',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesPostAsync
     *
     * Create sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchesPostAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdMatchesPostAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesPostAsyncWithHttpInfo
     *
     * Create sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchesPostAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMatching';
        $request = $this->restElasticSyncSyncSyncIdMatchesPostRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdMatchesPost'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdMatchesPostRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPost'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdMatchesPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/matches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesPut
     *
     * Update sync matches.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMatching
     */
    public function restElasticSyncSyncSyncIdMatchesPut(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'][0]
    ): \ck\Model\ElasticSyncMatching
    {
        list($response) = $this->restElasticSyncSyncSyncIdMatchesPutWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesPutWithHttpInfo
     *
     * Update sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMatching, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdMatchesPutWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdMatchesPutRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMatching' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMatching' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMatching', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMatching';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMatching',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesPutAsync
     *
     * Update sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchesPutAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdMatchesPutAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchesPutAsyncWithHttpInfo
     *
     * Update sync matches.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchesPutAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMatching';
        $request = $this->restElasticSyncSyncSyncIdMatchesPutRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdMatchesPut'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdMatchesPutRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchesPut'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdMatchesPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/matches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchingEntityGet
     *
     * Get an entity.
     *
     * @param  int $sync_id The sync ID of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncSyncIdMatchingEntityGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncSyncIdMatchingEntityGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchingEntityGetWithHttpInfo
     *
     * Get an entity.
     *
     * @param  int $sync_id The sync ID of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdMatchingEntityGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdMatchingEntityGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchingEntityGetAsync
     *
     * Get an entity.
     *
     * @param  int $sync_id The sync ID of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchingEntityGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdMatchingEntityGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchingEntityGetAsyncWithHttpInfo
     *
     * Get an entity.
     *
     * @param  int $sync_id The sync ID of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchingEntityGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncSyncIdMatchingEntityGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdMatchingEntityGet'
     *
     * @param  int $sync_id The sync ID of the mapping (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdMatchingEntityGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingEntityGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdMatchingEntityGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/matching/entity';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchingPost
     *
     * Create a sync matching.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncMatching
     */
    public function restElasticSyncSyncSyncIdMatchingPost(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'][0]
    ): \ck\Model\ElasticSyncMatching
    {
        list($response) = $this->restElasticSyncSyncSyncIdMatchingPostWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchingPostWithHttpInfo
     *
     * Create a sync matching.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncMatching, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdMatchingPostWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdMatchingPostRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncMatching' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncMatching' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncMatching', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncMatching';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncMatching',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchingPostAsync
     *
     * Create a sync matching.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchingPostAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdMatchingPostAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdMatchingPostAsyncWithHttpInfo
     *
     * Create a sync matching.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdMatchingPostAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncMatching';
        $request = $this->restElasticSyncSyncSyncIdMatchingPostRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdMatchingPost'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdMatchingPostRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdMatchingPost'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdMatchingPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/matching';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionPost
     *
     * Create a sync option.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncOption
     */
    public function restElasticSyncSyncSyncIdOptionPost(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionPost'][0]
    ): \ck\Model\ElasticSyncOption
    {
        list($response) = $this->restElasticSyncSyncSyncIdOptionPostWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionPostWithHttpInfo
     *
     * Create a sync option.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdOptionPostWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdOptionPostRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionPostAsync
     *
     * Create a sync option.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdOptionPostAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdOptionPostAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionPostAsyncWithHttpInfo
     *
     * Create a sync option.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdOptionPostAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncOption';
        $request = $this->restElasticSyncSyncSyncIdOptionPostRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdOptionPost'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdOptionPostRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionPost'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdOptionPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/option';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsGet
     *
     * List syncs.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restElasticSyncSyncSyncIdOptionsGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'][0]
    ): object
    {
        list($response) = $this->restElasticSyncSyncSyncIdOptionsGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsGetWithHttpInfo
     *
     * List syncs.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdOptionsGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdOptionsGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsGetAsync
     *
     * List syncs.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdOptionsGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdOptionsGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsGetAsyncWithHttpInfo
     *
     * List syncs.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdOptionsGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restElasticSyncSyncSyncIdOptionsGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdOptionsGet'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdOptionsGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdOptionsGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsPost
     *
     * Create sync options.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncOption
     */
    public function restElasticSyncSyncSyncIdOptionsPost(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'][0]
    ): \ck\Model\ElasticSyncOption
    {
        list($response) = $this->restElasticSyncSyncSyncIdOptionsPostWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsPostWithHttpInfo
     *
     * Create sync options.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdOptionsPostWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdOptionsPostRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsPostAsync
     *
     * Create sync options.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdOptionsPostAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdOptionsPostAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsPostAsyncWithHttpInfo
     *
     * Create sync options.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdOptionsPostAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncOption';
        $request = $this->restElasticSyncSyncSyncIdOptionsPostRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdOptionsPost'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdOptionsPostRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPost'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdOptionsPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsPut
     *
     * Update sync options.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncSyncIdOptionsPut(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncSyncIdOptionsPutWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsPutWithHttpInfo
     *
     * Update sync options.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdOptionsPutWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdOptionsPutRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsPutAsync
     *
     * Update sync options.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdOptionsPutAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdOptionsPutAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdOptionsPutAsyncWithHttpInfo
     *
     * Update sync options.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdOptionsPutAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncSyncIdOptionsPutRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdOptionsPut'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdOptionsPutRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdOptionsPut'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdOptionsPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdPreviewValuesGet
     *
     * Get preview of csv values.
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncSyncIdPreviewValuesGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncSyncIdPreviewValuesGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdPreviewValuesGetWithHttpInfo
     *
     * Get preview of csv values.
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdPreviewValuesGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdPreviewValuesGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdPreviewValuesGetAsync
     *
     * Get preview of csv values.
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdPreviewValuesGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdPreviewValuesGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdPreviewValuesGetAsyncWithHttpInfo
     *
     * Get preview of csv values.
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdPreviewValuesGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncSyncIdPreviewValuesGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdPreviewValuesGet'
     *
     * @param  int $sync_id The id of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdPreviewValuesGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPreviewValuesGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdPreviewValuesGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/preview-values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdPut
     *
     * Update a sync.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncSyncIdPut(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPut'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncSyncIdPutWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdPutWithHttpInfo
     *
     * Update a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdPutWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPut'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdPutRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdPutAsync
     *
     * Update a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdPutAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPut'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdPutAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdPutAsyncWithHttpInfo
     *
     * Update a sync.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdPutAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncSyncIdPutRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdPut'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdPutRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdPut'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdPut'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdRunPost
     *
     * Execute the run procedure.
     *
     * @param  int $sync_id The ID of the sync (required)
     * @param  int $testrun The test run variable (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdRunPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restElasticSyncSyncSyncIdRunPost(
        int $sync_id,
        int $testrun,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdRunPost'][0]
    ): void
    {
        $this->restElasticSyncSyncSyncIdRunPostWithHttpInfo($sync_id, $testrun, $contentType);
    }

    /**
     * Operation restElasticSyncSyncSyncIdRunPostWithHttpInfo
     *
     * Execute the run procedure.
     *
     * @param  int $sync_id The ID of the sync (required)
     * @param  int $testrun The test run variable (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdRunPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdRunPostWithHttpInfo(
        int $sync_id,
        int $testrun,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdRunPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdRunPostRequest($sync_id, $testrun, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdRunPostAsync
     *
     * Execute the run procedure.
     *
     * @param  int $sync_id The ID of the sync (required)
     * @param  int $testrun The test run variable (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdRunPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdRunPostAsync(
        int $sync_id,
        int $testrun,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdRunPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdRunPostAsyncWithHttpInfo($sync_id, $testrun, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdRunPostAsyncWithHttpInfo
     *
     * Execute the run procedure.
     *
     * @param  int $sync_id The ID of the sync (required)
     * @param  int $testrun The test run variable (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdRunPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdRunPostAsyncWithHttpInfo(
        $sync_id,
        $testrun,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdRunPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restElasticSyncSyncSyncIdRunPostRequest($sync_id, $testrun, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdRunPost'
     *
     * @param  int $sync_id The ID of the sync (required)
     * @param  int $testrun The test run variable (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdRunPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdRunPostRequest(
        $sync_id,
        $testrun,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdRunPost'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdRunPost'
            );
        }

        // verify the required parameter 'testrun' is set
        if ($testrun === null || (is_array($testrun) && count($testrun) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $testrun when calling restElasticSyncSyncSyncIdRunPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/run';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $testrun,
            'testrun', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncIdSourcePreviewGet
     *
     * Preview the syncs.
     *
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncSyncIdSourcePreviewGet(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncSyncIdSourcePreviewGetWithHttpInfo($sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncIdSourcePreviewGetWithHttpInfo
     *
     * Preview the syncs.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncIdSourcePreviewGetWithHttpInfo(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncIdSourcePreviewGetRequest($sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncIdSourcePreviewGetAsync
     *
     * Preview the syncs.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdSourcePreviewGetAsync(
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncIdSourcePreviewGetAsyncWithHttpInfo($sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncIdSourcePreviewGetAsyncWithHttpInfo
     *
     * Preview the syncs.
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncIdSourcePreviewGetAsyncWithHttpInfo(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncSyncIdSourcePreviewGetRequest($sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncIdSourcePreviewGet'
     *
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncIdSourcePreviewGetRequest(
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncIdSourcePreviewGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncSyncIdSourcePreviewGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncId}/source-preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncSyncTypeMatchingFieldsGet
     *
     * Get a list of all mappings for a particular sync type.
     *
     * @param  string $sync_type The sync type of the matching (required)
     * @param  int $sync_type2 sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncSyncTypeMatchingFieldsGet(
        string $sync_type,
        int $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncSyncTypeMatchingFieldsGetWithHttpInfo($sync_type, $sync_type2, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncSyncTypeMatchingFieldsGetWithHttpInfo
     *
     * Get a list of all mappings for a particular sync type.
     *
     * @param  string $sync_type The sync type of the matching (required)
     * @param  int $sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncSyncTypeMatchingFieldsGetWithHttpInfo(
        string $sync_type,
        int $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncSyncTypeMatchingFieldsGetRequest($sync_type, $sync_type2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncSyncTypeMatchingFieldsGetAsync
     *
     * Get a list of all mappings for a particular sync type.
     *
     * @param  string $sync_type The sync type of the matching (required)
     * @param  int $sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncTypeMatchingFieldsGetAsync(
        string $sync_type,
        int $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncSyncTypeMatchingFieldsGetAsyncWithHttpInfo($sync_type, $sync_type2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncSyncTypeMatchingFieldsGetAsyncWithHttpInfo
     *
     * Get a list of all mappings for a particular sync type.
     *
     * @param  string $sync_type The sync type of the matching (required)
     * @param  int $sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncSyncTypeMatchingFieldsGetAsyncWithHttpInfo(
        $sync_type,
        $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncSyncTypeMatchingFieldsGetRequest($sync_type, $sync_type2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncSyncTypeMatchingFieldsGet'
     *
     * @param  string $sync_type The sync type of the matching (required)
     * @param  int $sync_type2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncSyncTypeMatchingFieldsGetRequest(
        $sync_type,
        $sync_type2,
        string $contentType = self::contentTypes['restElasticSyncSyncSyncTypeMatchingFieldsGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_type' is set
        if ($sync_type === null || (is_array($sync_type) && count($sync_type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_type when calling restElasticSyncSyncSyncTypeMatchingFieldsGet'
            );
        }

        // verify the required parameter 'sync_type2' is set
        if ($sync_type2 === null || (is_array($sync_type2) && count($sync_type2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_type2 when calling restElasticSyncSyncSyncTypeMatchingFieldsGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/sync/{syncType}/matching/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sync_type,
            '$syncType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($sync_type2 !== null) {
            $resourcePath = str_replace(
                '{' . 'syncType' . '}',
                ObjectSerializer::toPathValue($sync_type2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncTypesGet
     *
     * Get list of sync types.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncTypesGet(
        string $contentType = self::contentTypes['restElasticSyncSyncTypesGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncTypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncTypesGetWithHttpInfo
     *
     * Get list of sync types.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncTypesGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncTypesGetAsync
     *
     * Get list of sync types.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncTypesGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncTypesGetAsyncWithHttpInfo
     *
     * Get list of sync types.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncTypesGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/sync/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncsCopyPost
     *
     * Copy the syncs.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsCopyPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncsCopyPost(
        string $contentType = self::contentTypes['restElasticSyncSyncsCopyPost'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncsCopyPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncsCopyPostWithHttpInfo
     *
     * Copy the syncs.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsCopyPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncsCopyPostWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncsCopyPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncsCopyPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncsCopyPostAsync
     *
     * Copy the syncs.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsCopyPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsCopyPostAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncsCopyPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncsCopyPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncsCopyPostAsyncWithHttpInfo
     *
     * Copy the syncs.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsCopyPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsCopyPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncsCopyPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncsCopyPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncsCopyPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsCopyPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncsCopyPostRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncsCopyPost'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/syncs/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncsDelete
     *
     * Delete syncs.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ElasticSyncSync
     */
    public function restElasticSyncSyncsDelete(
        string $contentType = self::contentTypes['restElasticSyncSyncsDelete'][0]
    ): \ck\Model\ElasticSyncSync
    {
        list($response) = $this->restElasticSyncSyncsDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncsDeleteWithHttpInfo
     *
     * Delete syncs.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ElasticSyncSync, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncsDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncsDelete'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncsDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ElasticSyncSync' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ElasticSyncSync' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ElasticSyncSync', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ElasticSyncSync';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ElasticSyncSync',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncsDeleteAsync
     *
     * Delete syncs.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsDeleteAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncsDelete'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncsDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncsDeleteAsyncWithHttpInfo
     *
     * Delete syncs.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ElasticSyncSync';
        $request = $this->restElasticSyncSyncsDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncsDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncsDeleteRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncsDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/syncs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncsExportPost
     *
     * Export the syncs.
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncsExportPost(
        int $sync_ids,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportPost'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncsExportPostWithHttpInfo($sync_ids, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncsExportPostWithHttpInfo
     *
     * Export the syncs.
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncsExportPostWithHttpInfo(
        int $sync_ids,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportPost'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncsExportPostRequest($sync_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncsExportPostAsync
     *
     * Export the syncs.
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsExportPostAsync(
        int $sync_ids,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportPost'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncsExportPostAsyncWithHttpInfo($sync_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncsExportPostAsyncWithHttpInfo
     *
     * Export the syncs.
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsExportPostAsyncWithHttpInfo(
        $sync_ids,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncsExportPostRequest($sync_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncsExportPost'
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncsExportPostRequest(
        $sync_ids,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportPost'][0]
    ): Request
    {

        // verify the required parameter 'sync_ids' is set
        if ($sync_ids === null || (is_array($sync_ids) && count($sync_ids) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_ids when calling restElasticSyncSyncsExportPost'
            );
        }


        $resourcePath = '/rest/elastic-sync/syncs/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sync_ids,
            'syncIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncsExportSyncIdGet
     *
     * Export the sync.
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  int $sync_id sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportSyncIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restElasticSyncSyncsExportSyncIdGet(
        int $sync_ids,
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportSyncIdGet'][0]
    ): array
    {
        list($response) = $this->restElasticSyncSyncsExportSyncIdGetWithHttpInfo($sync_ids, $sync_id, $contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncsExportSyncIdGetWithHttpInfo
     *
     * Export the sync.
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportSyncIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncsExportSyncIdGetWithHttpInfo(
        int $sync_ids,
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportSyncIdGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncsExportSyncIdGetRequest($sync_ids, $sync_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncsExportSyncIdGetAsync
     *
     * Export the sync.
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsExportSyncIdGetAsync(
        int $sync_ids,
        int $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportSyncIdGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncsExportSyncIdGetAsyncWithHttpInfo($sync_ids, $sync_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncsExportSyncIdGetAsyncWithHttpInfo
     *
     * Export the sync.
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsExportSyncIdGetAsyncWithHttpInfo(
        $sync_ids,
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportSyncIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restElasticSyncSyncsExportSyncIdGetRequest($sync_ids, $sync_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncsExportSyncIdGet'
     *
     * @param  int $sync_ids The ID of the sync (required)
     * @param  int $sync_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsExportSyncIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncsExportSyncIdGetRequest(
        $sync_ids,
        $sync_id,
        string $contentType = self::contentTypes['restElasticSyncSyncsExportSyncIdGet'][0]
    ): Request
    {

        // verify the required parameter 'sync_ids' is set
        if ($sync_ids === null || (is_array($sync_ids) && count($sync_ids) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_ids when calling restElasticSyncSyncsExportSyncIdGet'
            );
        }

        // verify the required parameter 'sync_id' is set
        if ($sync_id === null || (is_array($sync_id) && count($sync_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sync_id when calling restElasticSyncSyncsExportSyncIdGet'
            );
        }


        $resourcePath = '/rest/elastic-sync/syncs/export/{syncId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sync_ids,
            'syncIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($sync_id !== null) {
            $resourcePath = str_replace(
                '{' . 'syncId' . '}',
                ObjectSerializer::toPathValue($sync_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restElasticSyncSyncsGet
     *
     * Get all Syncs
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
     */
    public function restElasticSyncSyncsGet(
        string $contentType = self::contentTypes['restElasticSyncSyncsGet'][0]
    ): \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
    {
        list($response) = $this->restElasticSyncSyncsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restElasticSyncSyncsGetWithHttpInfo
     *
     * Get all Syncs
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restElasticSyncSyncsGetWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncsGet'][0]
    ): array
    {
        $request = $this->restElasticSyncSyncsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restElasticSyncSyncsGetAsync
     *
     * Get all Syncs
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsGetAsync(
        string $contentType = self::contentTypes['restElasticSyncSyncsGet'][0]
    ): PromiseInterface
    {
        return $this->restElasticSyncSyncsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restElasticSyncSyncsGetAsyncWithHttpInfo
     *
     * Get all Syncs
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restElasticSyncSyncsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restElasticSyncSyncsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
        $request = $this->restElasticSyncSyncsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restElasticSyncSyncsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restElasticSyncSyncsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restElasticSyncSyncsGetRequest(
        string $contentType = self::contentTypes['restElasticSyncSyncsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/elastic-sync/syncs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
