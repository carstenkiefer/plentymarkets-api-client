<?php
/**
 * AccountingApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * AccountingApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AccountingApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restAccountingLocationsExistingAccountsGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdDebtorAccountConfigurationsGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdDebtorAccountsModeGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdDelete' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdPostingAccountsGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdPostingKeyConfigurationsGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdPut' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdRevenueAccountConfigurationsGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdSettingsGet' => [
            'application/json',
        ],
        'restAccountingLocationsLocationIdTypePostingAccountsGet' => [
            'application/json',
        ],
        'restAccountingLocationsPost' => [
            'application/json',
        ],
        'restAccountingLocationsPostingAccountsGet' => [
            'application/json',
        ],
        'restAccountingLocationsPostingAccountsIdDelete' => [
            'application/json',
        ],
        'restAccountingLocationsPostingAccountsIdGet' => [
            'application/json',
        ],
        'restAccountingLocationsPostingAccountsPost' => [
            'application/json',
        ],
        'restAccountingLocationsRevenueAccountConfigurationsGet' => [
            'application/json',
        ],
        'restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet' => [
            'application/json',
        ],
        'restAccountingStoresLocationsGet' => [
            'application/json',
        ],
        'restAccountingStoresPlentyIdLocationsGet' => [
            'application/json',
        ],
        'restStoresPlentyIdLocationsGet' => [
            'application/json',
        ],
        'restVatGet' => [
            'application/json',
        ],
        'restVatLocationsLocationIdCountriesCountryIdDateDateGet' => [
            'application/json',
        ],
        'restVatLocationsLocationIdCountriesCountryIdGet' => [
            'application/json',
        ],
        'restVatLocationsLocationIdGet' => [
            'application/json',
        ],
        'restVatPost' => [
            'application/json',
        ],
        'restVatStandardGet' => [
            'application/json',
        ],
        'restVatVatIdGet' => [
            'application/json',
        ],
        'restVatVatIdPut' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGet
     *
     * Get all unique posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsExistingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PostingAccounts[]
     */
    public function restAccountingLocationsExistingAccountsGet(
        string $contentType = self::contentTypes['restAccountingLocationsExistingAccountsGet'][0]
    ): array
    {
        list($response) = $this->restAccountingLocationsExistingAccountsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetWithHttpInfo
     *
     * Get all unique posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsExistingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsExistingAccountsGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountingLocationsExistingAccountsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsExistingAccountsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PostingAccounts[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PostingAccounts[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PostingAccounts[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PostingAccounts[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetAsync
     *
     * Get all unique posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsExistingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsExistingAccountsGetAsync(
        string $contentType = self::contentTypes['restAccountingLocationsExistingAccountsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo
     *
     * Get all unique posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsExistingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountingLocationsExistingAccountsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PostingAccounts[]';
        $request = $this->restAccountingLocationsExistingAccountsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsExistingAccountsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsExistingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsExistingAccountsGetRequest(
        string $contentType = self::contentTypes['restAccountingLocationsExistingAccountsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounting/locations/existing_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet
     *
     * Get the revenue account configuration of a country
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RevenueAccountCountryConfiguration
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet(
        int $location_id,
        int $country_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'][0]
    ): \ck\Model\RevenueAccountCountryConfiguration
    {
        list($response) = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo($location_id, $country_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo
     *
     * Get the revenue account configuration of a country
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RevenueAccountCountryConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo(
        int $location_id,
        int $country_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest($location_id, $country_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RevenueAccountCountryConfiguration' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RevenueAccountCountryConfiguration' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RevenueAccountCountryConfiguration', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RevenueAccountCountryConfiguration';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RevenueAccountCountryConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsync
     *
     * Get the revenue account configuration of a country
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsync(
        int $location_id,
        int $country_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo($location_id, $country_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo
     *
     * Get the revenue account configuration of a country
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo(
        $location_id,
        $country_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RevenueAccountCountryConfiguration';
        $request = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest($location_id, $country_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest(
        $location_id,
        $country_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
            );
        }

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}/countries/{countryId}/revenue_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGet
     *
     * Get debtor account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\DebtorAccountConfiguration
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGet(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'][0]
    ): \ck\Model\DebtorAccountConfiguration
    {
        list($response) = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo($location_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo
     *
     * Get debtor account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\DebtorAccountConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest($location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\DebtorAccountConfiguration' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\DebtorAccountConfiguration' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\DebtorAccountConfiguration', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\DebtorAccountConfiguration';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\DebtorAccountConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsync
     *
     * Get debtor account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsync(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo($location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo
     *
     * Get debtor account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\DebtorAccountConfiguration';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest($location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}/debtor_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGet
     *
     * Lists the debtor accounts by mode.
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGet(
        int $location_id,
        string $mode,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'][0]
    ): object
    {
        list($response) = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo($location_id, $mode, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo
     *
     * Lists the debtor accounts by mode.
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo(
        int $location_id,
        string $mode,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetRequest($location_id, $mode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetAsync
     *
     * Lists the debtor accounts by mode.
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetAsync(
        int $location_id,
        string $mode,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo($location_id, $mode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo
     *
     * Lists the debtor accounts by mode.
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo(
        $location_id,
        $mode,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetRequest($location_id, $mode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDebtorAccountsModeGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetRequest(
        $location_id,
        $mode,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDebtorAccountsModeGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDebtorAccountsModeGet'
            );
        }

        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mode when calling restAccountingLocationsLocationIdDebtorAccountsModeGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}/debtor_accounts/{mode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($mode !== null) {
            $resourcePath = str_replace(
                '{' . 'mode' . '}',
                ObjectSerializer::toPathValue($mode),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDelete
     *
     * Delete an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountingLocationsLocationIdDelete(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDelete'][0]
    ): void
    {
        $this->restAccountingLocationsLocationIdDeleteWithHttpInfo($location_id, $contentType);
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteWithHttpInfo
     *
     * Delete an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdDeleteWithHttpInfo(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDelete'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdDeleteRequest($location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteAsync
     *
     * Delete an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdDeleteAsync(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo($location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo
     *
     * Delete an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountingLocationsLocationIdDeleteRequest($location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDelete'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdDeleteRequest(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDelete'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdGet
     *
     * Get an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AccountingLocation
     */
    public function restAccountingLocationsLocationIdGet(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdGet'][0]
    ): \ck\Model\AccountingLocation
    {
        list($response) = $this->restAccountingLocationsLocationIdGetWithHttpInfo($location_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdGetWithHttpInfo
     *
     * Get an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AccountingLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdGetWithHttpInfo(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdGetRequest($location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AccountingLocation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AccountingLocation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AccountingLocation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AccountingLocation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdGetAsync
     *
     * Get an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdGetAsync(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdGetAsyncWithHttpInfo($location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdGetAsyncWithHttpInfo
     *
     * Get an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdGetAsyncWithHttpInfo(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AccountingLocation';
        $request = $this->restAccountingLocationsLocationIdGetRequest($location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdGetRequest(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGet
     *
     * Get all posting accounts by locationId
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PostingAccounts[]
     */
    public function restAccountingLocationsLocationIdPostingAccountsGet(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'][0]
    ): array
    {
        list($response) = $this->restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo($location_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts by locationId
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdPostingAccountsGetRequest($location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PostingAccounts[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PostingAccounts[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PostingAccounts[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PostingAccounts[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetAsync
     *
     * Get all posting accounts by locationId
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetAsync(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo($location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts by locationId
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdPostingAccountsGetRequest($location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPostingAccountsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetRequest(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingAccountsGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPostingAccountsGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGet
     *
     * Get a posting key configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PostingKeyConfiguration
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGet(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'][0]
    ): \ck\Model\PostingKeyConfiguration
    {
        list($response) = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo($location_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo
     *
     * Get a posting key configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PostingKeyConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest($location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PostingKeyConfiguration' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PostingKeyConfiguration' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PostingKeyConfiguration', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PostingKeyConfiguration';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PostingKeyConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsync
     *
     * Get a posting key configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsync(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo($location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo
     *
     * Get a posting key configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PostingKeyConfiguration';
        $request = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest($location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPostingKeyConfigurationsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPostingKeyConfigurationsGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPostingKeyConfigurationsGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}/posting_key_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPut
     *
     * Update an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  \ck\Model\RestAccountingLocationsLocationIdPutRequest|null $_rest_accounting_locations_location_id _rest_accounting_locations_location_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AccountingLocation
     */
    public function restAccountingLocationsLocationIdPut(
        int $location_id,
        ?\ck\Model\RestAccountingLocationsLocationIdPutRequest $_rest_accounting_locations_location_id = null,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPut'][0]
    ): \ck\Model\AccountingLocation
    {
        list($response) = $this->restAccountingLocationsLocationIdPutWithHttpInfo($location_id, $_rest_accounting_locations_location_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPutWithHttpInfo
     *
     * Update an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  \ck\Model\RestAccountingLocationsLocationIdPutRequest|null $_rest_accounting_locations_location_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AccountingLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdPutWithHttpInfo(
        int $location_id,
        ?\ck\Model\RestAccountingLocationsLocationIdPutRequest $_rest_accounting_locations_location_id = null,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPut'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdPutRequest($location_id, $_rest_accounting_locations_location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AccountingLocation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AccountingLocation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AccountingLocation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AccountingLocation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPutAsync
     *
     * Update an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  \ck\Model\RestAccountingLocationsLocationIdPutRequest|null $_rest_accounting_locations_location_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdPutAsync(
        int $location_id,
        ?\ck\Model\RestAccountingLocationsLocationIdPutRequest $_rest_accounting_locations_location_id = null,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdPutAsyncWithHttpInfo($location_id, $_rest_accounting_locations_location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPutAsyncWithHttpInfo
     *
     * Update an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  \ck\Model\RestAccountingLocationsLocationIdPutRequest|null $_rest_accounting_locations_location_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdPutAsyncWithHttpInfo(
        $location_id,
        $_rest_accounting_locations_location_id = null,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AccountingLocation';
        $request = $this->restAccountingLocationsLocationIdPutRequest($location_id, $_rest_accounting_locations_location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPut'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  \ck\Model\RestAccountingLocationsLocationIdPutRequest|null $_rest_accounting_locations_location_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdPutRequest(
        $location_id,
        $_rest_accounting_locations_location_id = null,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdPut'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPut'
            );
        }



        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounting_locations_location_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounting_locations_location_id));
            } else {
                $httpBody = $_rest_accounting_locations_location_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGet
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RevenueAccountLocationConfiguration
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGet(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'][0]
    ): \ck\Model\RevenueAccountLocationConfiguration
    {
        list($response) = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo($location_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RevenueAccountLocationConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest($location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RevenueAccountLocationConfiguration' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RevenueAccountLocationConfiguration' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RevenueAccountLocationConfiguration', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RevenueAccountLocationConfiguration';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RevenueAccountLocationConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsync
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsync(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo($location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RevenueAccountLocationConfiguration';
        $request = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest($location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}/revenue_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGet
     *
     * Get accounting location settings
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdSettingsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AccountingLocationSettings
     */
    public function restAccountingLocationsLocationIdSettingsGet(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdSettingsGet'][0]
    ): \ck\Model\AccountingLocationSettings
    {
        list($response) = $this->restAccountingLocationsLocationIdSettingsGetWithHttpInfo($location_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetWithHttpInfo
     *
     * Get accounting location settings
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdSettingsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AccountingLocationSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdSettingsGetWithHttpInfo(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdSettingsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdSettingsGetRequest($location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AccountingLocationSettings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AccountingLocationSettings' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AccountingLocationSettings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AccountingLocationSettings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AccountingLocationSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetAsync
     *
     * Get accounting location settings
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdSettingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdSettingsGetAsync(
        int $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdSettingsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo($location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo
     *
     * Get accounting location settings
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdSettingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdSettingsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AccountingLocationSettings';
        $request = $this->restAccountingLocationsLocationIdSettingsGetRequest($location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdSettingsGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdSettingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdSettingsGetRequest(
        $location_id,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdSettingsGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdSettingsGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGet
     *
     * Get all posting accounts by locationId and type
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PostingAccounts[]
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGet(
        int $location_id,
        string $type,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'][0]
    ): array
    {
        list($response) = $this->restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo($location_id, $type, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts by locationId and type
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo(
        int $location_id,
        string $type,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsLocationIdTypePostingAccountsGetRequest($location_id, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PostingAccounts[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PostingAccounts[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PostingAccounts[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PostingAccounts[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetAsync
     *
     * Get all posting accounts by locationId and type
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetAsync(
        int $location_id,
        string $type,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo($location_id, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts by locationId and type
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo(
        $location_id,
        $type,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdTypePostingAccountsGetRequest($location_id, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdTypePostingAccountsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetRequest(
        $location_id,
        $type,
        string $contentType = self::contentTypes['restAccountingLocationsLocationIdTypePostingAccountsGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdTypePostingAccountsGet'
            );
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restAccountingLocationsLocationIdTypePostingAccountsGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{locationId}/{type}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPost
     *
     * Create an accounting location
     *
     * @param  \ck\Model\RestAccountingLocationsPostRequest|null $_rest_accounting_locations _rest_accounting_locations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AccountingLocation
     */
    public function restAccountingLocationsPost(
        ?\ck\Model\RestAccountingLocationsPostRequest $_rest_accounting_locations = null,
        string $contentType = self::contentTypes['restAccountingLocationsPost'][0]
    ): \ck\Model\AccountingLocation
    {
        list($response) = $this->restAccountingLocationsPostWithHttpInfo($_rest_accounting_locations, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostWithHttpInfo
     *
     * Create an accounting location
     *
     * @param  \ck\Model\RestAccountingLocationsPostRequest|null $_rest_accounting_locations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AccountingLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostWithHttpInfo(
        ?\ck\Model\RestAccountingLocationsPostRequest $_rest_accounting_locations = null,
        string $contentType = self::contentTypes['restAccountingLocationsPost'][0]
    ): array
    {
        $request = $this->restAccountingLocationsPostRequest($_rest_accounting_locations, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AccountingLocation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AccountingLocation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AccountingLocation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AccountingLocation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostAsync
     *
     * Create an accounting location
     *
     * @param  \ck\Model\RestAccountingLocationsPostRequest|null $_rest_accounting_locations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostAsync(
        ?\ck\Model\RestAccountingLocationsPostRequest $_rest_accounting_locations = null,
        string $contentType = self::contentTypes['restAccountingLocationsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsPostAsyncWithHttpInfo($_rest_accounting_locations, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostAsyncWithHttpInfo
     *
     * Create an accounting location
     *
     * @param  \ck\Model\RestAccountingLocationsPostRequest|null $_rest_accounting_locations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostAsyncWithHttpInfo(
        $_rest_accounting_locations = null,
        string $contentType = self::contentTypes['restAccountingLocationsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AccountingLocation';
        $request = $this->restAccountingLocationsPostRequest($_rest_accounting_locations, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPost'
     *
     * @param  \ck\Model\RestAccountingLocationsPostRequest|null $_rest_accounting_locations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsPostRequest(
        $_rest_accounting_locations = null,
        string $contentType = self::contentTypes['restAccountingLocationsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounting/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounting_locations)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounting_locations));
            } else {
                $httpBody = $_rest_accounting_locations;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGet
     *
     * Get all posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PostingAccounts[]
     */
    public function restAccountingLocationsPostingAccountsGet(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsGet'][0]
    ): array
    {
        list($response) = $this->restAccountingLocationsPostingAccountsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostingAccountsGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsPostingAccountsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PostingAccounts[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PostingAccounts[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PostingAccounts[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PostingAccounts[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetAsync
     *
     * Get all posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsGetAsync(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsPostingAccountsGetRequest(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounting/locations/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDelete
     *
     * Delete an posting account
     *
     * @param  int $id The ID of the posting account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountingLocationsPostingAccountsIdDelete(
        int $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'][0]
    ): void
    {
        $this->restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo
     *
     * Delete an posting account
     *
     * @param  int $id The ID of the posting account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'][0]
    ): array
    {
        $request = $this->restAccountingLocationsPostingAccountsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteAsync
     *
     * Delete an posting account
     *
     * @param  int $id The ID of the posting account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo
     *
     * Delete an posting account
     *
     * @param  int $id The ID of the posting account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountingLocationsPostingAccountsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsIdDelete'
     *
     * @param  int $id The ID of the posting account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsPostingAccountsIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restAccountingLocationsPostingAccountsIdDelete'
            );
        }


        $resourcePath = '/rest/accounting/locations/posting_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGet
     *
     * Gets posting account by the unique id
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PostingAccounts
     */
    public function restAccountingLocationsPostingAccountsIdGet(
        int $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdGet'][0]
    ): \ck\Model\PostingAccounts
    {
        list($response) = $this->restAccountingLocationsPostingAccountsIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetWithHttpInfo
     *
     * Gets posting account by the unique id
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PostingAccounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostingAccountsIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsPostingAccountsIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PostingAccounts' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PostingAccounts' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PostingAccounts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PostingAccounts';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PostingAccounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetAsync
     *
     * Gets posting account by the unique id
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo
     *
     * Gets posting account by the unique id
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PostingAccounts';
        $request = $this->restAccountingLocationsPostingAccountsIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsPostingAccountsIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restAccountingLocationsPostingAccountsIdGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/posting_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPost
     *
     * Save posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PostingAccounts[]
     */
    public function restAccountingLocationsPostingAccountsPost(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsPost'][0]
    ): array
    {
        list($response) = $this->restAccountingLocationsPostingAccountsPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostWithHttpInfo
     *
     * Save posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostingAccountsPostWithHttpInfo(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsPost'][0]
    ): array
    {
        $request = $this->restAccountingLocationsPostingAccountsPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PostingAccounts[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PostingAccounts[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PostingAccounts[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PostingAccounts[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostAsync
     *
     * Save posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsPostAsync(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo
     *
     * Save posting accounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsPostingAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsPostingAccountsPostRequest(
        string $contentType = self::contentTypes['restAccountingLocationsPostingAccountsPost'][0]
    ): Request
    {


        $resourcePath = '/rest/accounting/locations/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGet
     *
     * List revenue account configurations
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGet(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'][0]
    ): \ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response
    {
        list($response) = $this->restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo($page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo
     *
     * List revenue account configurations
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsRevenueAccountConfigurationsGetRequest($page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetAsync
     *
     * List revenue account configurations
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo($page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo
     *
     * List revenue account configurations
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountingLocationsRevenueAccountConfigurationsGet200Response';
        $request = $this->restAccountingLocationsRevenueAccountConfigurationsGetRequest($page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsRevenueAccountConfigurationsGet'
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetRequest(
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountingLocationsRevenueAccountConfigurationsGet'][0]
    ): Request
    {




        $resourcePath = '/rest/accounting/locations/revenue_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 webstore_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PostingAccounts[]
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet(
        int $country_id,
        int $webstore_id,
        int $webstore_id2,
        string $contentType = self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'][0]
    ): array
    {
        list($response) = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo($country_id, $webstore_id, $webstore_id2, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo(
        int $country_id,
        int $webstore_id,
        int $webstore_id2,
        string $contentType = self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'][0]
    ): array
    {
        $request = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest($country_id, $webstore_id, $webstore_id2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PostingAccounts[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PostingAccounts[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PostingAccounts[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PostingAccounts[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsync
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsync(
        int $country_id,
        int $webstore_id,
        int $webstore_id2,
        string $contentType = self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo($country_id, $webstore_id, $webstore_id2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo(
        $country_id,
        $webstore_id,
        $webstore_id2,
        string $contentType = self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PostingAccounts[]';
        $request = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest($country_id, $webstore_id, $webstore_id2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest(
        $country_id,
        $webstore_id,
        $webstore_id2,
        string $contentType = self::contentTypes['restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'][0]
    ): Request
    {

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }

        // verify the required parameter 'webstore_id' is set
        if ($webstore_id === null || (is_array($webstore_id) && count($webstore_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webstore_id when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }

        // verify the required parameter 'webstore_id2' is set
        if ($webstore_id2 === null || (is_array($webstore_id2) && count($webstore_id2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webstore_id2 when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }


        $resourcePath = '/rest/accounting/locations/{webstoreId}/{countryId}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $webstore_id,
            '$webstoreId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }
        // path params
        if ($webstore_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'webstoreId' . '}',
                ObjectSerializer::toPathValue($webstore_id2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingStoresLocationsGet
     *
     * List all accounting locations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AccountingLocation[]
     */
    public function restAccountingStoresLocationsGet(
        string $contentType = self::contentTypes['restAccountingStoresLocationsGet'][0]
    ): array
    {
        list($response) = $this->restAccountingStoresLocationsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountingStoresLocationsGetWithHttpInfo
     *
     * List all accounting locations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AccountingLocation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingStoresLocationsGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountingStoresLocationsGet'][0]
    ): array
    {
        $request = $this->restAccountingStoresLocationsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AccountingLocation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AccountingLocation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AccountingLocation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AccountingLocation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AccountingLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingStoresLocationsGetAsync
     *
     * List all accounting locations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingStoresLocationsGetAsync(
        string $contentType = self::contentTypes['restAccountingStoresLocationsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingStoresLocationsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingStoresLocationsGetAsyncWithHttpInfo
     *
     * List all accounting locations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingStoresLocationsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountingStoresLocationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AccountingLocation[]';
        $request = $this->restAccountingStoresLocationsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingStoresLocationsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingStoresLocationsGetRequest(
        string $contentType = self::contentTypes['restAccountingStoresLocationsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounting/stores/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGet
     *
     * List accounting locations of a client
     *
     * @param  int $plenty_id plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AccountingLocation[]
     */
    public function restAccountingStoresPlentyIdLocationsGet(
        int $plenty_id,
        string $contentType = self::contentTypes['restAccountingStoresPlentyIdLocationsGet'][0]
    ): array
    {
        list($response) = $this->restAccountingStoresPlentyIdLocationsGetWithHttpInfo($plenty_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetWithHttpInfo
     *
     * List accounting locations of a client
     *
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AccountingLocation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingStoresPlentyIdLocationsGetWithHttpInfo(
        int $plenty_id,
        string $contentType = self::contentTypes['restAccountingStoresPlentyIdLocationsGet'][0]
    ): array
    {
        $request = $this->restAccountingStoresPlentyIdLocationsGetRequest($plenty_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AccountingLocation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AccountingLocation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AccountingLocation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AccountingLocation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AccountingLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetAsync
     *
     * List accounting locations of a client
     *
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingStoresPlentyIdLocationsGetAsync(
        int $plenty_id,
        string $contentType = self::contentTypes['restAccountingStoresPlentyIdLocationsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo
     *
     * List accounting locations of a client
     *
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo(
        $plenty_id,
        string $contentType = self::contentTypes['restAccountingStoresPlentyIdLocationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AccountingLocation[]';
        $request = $this->restAccountingStoresPlentyIdLocationsGetRequest($plenty_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingStoresPlentyIdLocationsGet'
     *
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountingStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountingStoresPlentyIdLocationsGetRequest(
        $plenty_id,
        string $contentType = self::contentTypes['restAccountingStoresPlentyIdLocationsGet'][0]
    ): Request
    {

        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restAccountingStoresPlentyIdLocationsGet'
            );
        }


        $resourcePath = '/rest/accounting/stores/{plentyId}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restStoresPlentyIdLocationsGet
     *
     * Get the ID of an accounting location of a country
     *
     * @param  int $plenty_id plenty_id (required)
     * @param  int|null $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AccountingLocation
     */
    public function restStoresPlentyIdLocationsGet(
        int $plenty_id,
        ?int $country_id = null,
        string $contentType = self::contentTypes['restStoresPlentyIdLocationsGet'][0]
    ): \ck\Model\AccountingLocation
    {
        list($response) = $this->restStoresPlentyIdLocationsGetWithHttpInfo($plenty_id, $country_id, $contentType);
        return $response;
    }

    /**
     * Operation restStoresPlentyIdLocationsGetWithHttpInfo
     *
     * Get the ID of an accounting location of a country
     *
     * @param  int $plenty_id (required)
     * @param  int|null $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AccountingLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restStoresPlentyIdLocationsGetWithHttpInfo(
        int $plenty_id,
        ?int $country_id = null,
        string $contentType = self::contentTypes['restStoresPlentyIdLocationsGet'][0]
    ): array
    {
        $request = $this->restStoresPlentyIdLocationsGetRequest($plenty_id, $country_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AccountingLocation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AccountingLocation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AccountingLocation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AccountingLocation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restStoresPlentyIdLocationsGetAsync
     *
     * Get the ID of an accounting location of a country
     *
     * @param  int $plenty_id (required)
     * @param  int|null $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restStoresPlentyIdLocationsGetAsync(
        int $plenty_id,
        ?int $country_id = null,
        string $contentType = self::contentTypes['restStoresPlentyIdLocationsGet'][0]
    ): PromiseInterface
    {
        return $this->restStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id, $country_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restStoresPlentyIdLocationsGetAsyncWithHttpInfo
     *
     * Get the ID of an accounting location of a country
     *
     * @param  int $plenty_id (required)
     * @param  int|null $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restStoresPlentyIdLocationsGetAsyncWithHttpInfo(
        $plenty_id,
        $country_id = null,
        string $contentType = self::contentTypes['restStoresPlentyIdLocationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AccountingLocation';
        $request = $this->restStoresPlentyIdLocationsGetRequest($plenty_id, $country_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restStoresPlentyIdLocationsGet'
     *
     * @param  int $plenty_id (required)
     * @param  int|null $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStoresPlentyIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restStoresPlentyIdLocationsGetRequest(
        $plenty_id,
        $country_id = null,
        string $contentType = self::contentTypes['restStoresPlentyIdLocationsGet'][0]
    ): Request
    {

        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restStoresPlentyIdLocationsGet'
            );
        }



        $resourcePath = '/rest/stores/{plentyId}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_id,
            'countryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatGet
     *
     * List VAT configurations.
     *
     * @param  int|null $page The requested page. (optional)
     * @param  int|null $items_per_page The number of items per page. (optional)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The properties to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestVatGet200Response
     */
    public function restVatGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatGet'][0]
    ): \ck\Model\RestVatGet200Response
    {
        list($response) = $this->restVatGetWithHttpInfo($page, $items_per_page, $with, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restVatGetWithHttpInfo
     *
     * List VAT configurations.
     *
     * @param  int|null $page The requested page. (optional)
     * @param  int|null $items_per_page The number of items per page. (optional)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The properties to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestVatGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatGet'][0]
    ): array
    {
        $request = $this->restVatGetRequest($page, $items_per_page, $with, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestVatGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestVatGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestVatGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestVatGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestVatGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatGetAsync
     *
     * List VAT configurations.
     *
     * @param  int|null $page The requested page. (optional)
     * @param  int|null $items_per_page The number of items per page. (optional)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The properties to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatGet'][0]
    ): PromiseInterface
    {
        return $this->restVatGetAsyncWithHttpInfo($page, $items_per_page, $with, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatGetAsyncWithHttpInfo
     *
     * List VAT configurations.
     *
     * @param  int|null $page The requested page. (optional)
     * @param  int|null $items_per_page The number of items per page. (optional)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The properties to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $with = null,
        $columns = null,
        string $contentType = self::contentTypes['restVatGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestVatGet200Response';
        $request = $this->restVatGetRequest($page, $items_per_page, $with, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatGet'
     *
     * @param  int|null $page The requested page. (optional)
     * @param  int|null $items_per_page The number of items per page. (optional)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The properties to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restVatGetRequest(
        $page = null,
        $items_per_page = null,
        $with = null,
        $columns = null,
        string $contentType = self::contentTypes['restVatGet'][0]
    ): Request
    {






        $resourcePath = '/rest/vat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGet
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date date (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Vat
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGet(
        int $location_id,
        int $country_id,
        string $start_date,
        int $date,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'][0]
    ): \ck\Model\Vat
    {
        list($response) = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo($location_id, $country_id, $start_date, $date, $with, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Vat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo(
        int $location_id,
        int $country_id,
        string $start_date,
        int $date,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'][0]
    ): array
    {
        $request = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest($location_id, $country_id, $start_date, $date, $with, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Vat' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Vat' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Vat', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Vat';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Vat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetAsync
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetAsync(
        int $location_id,
        int $country_id,
        string $start_date,
        int $date,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'][0]
    ): PromiseInterface
    {
        return $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo($location_id, $country_id, $start_date, $date, $with, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo(
        $location_id,
        $country_id,
        $start_date,
        $date,
        $with = null,
        $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Vat';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest($location_id, $country_id, $start_date, $date, $with, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdCountriesCountryIdDateDateGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest(
        $location_id,
        $country_id,
        $start_date,
        $date,
        $with = null,
        $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdDateDateGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }

        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $start_date when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $date when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }




        $resourcePath = '/rest/vat/locations/{locationId}/countries/{countryId}/date/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with[]', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns[]', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }
        // path params
        if ($date !== null) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGet
     *
     * List VAT configurations for one country of delivery
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Vat[]
     */
    public function restVatLocationsLocationIdCountriesCountryIdGet(
        int $location_id,
        int $country_id,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'][0]
    ): array
    {
        list($response) = $this->restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo($location_id, $country_id, $with, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo
     *
     * List VAT configurations for one country of delivery
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Vat[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo(
        int $location_id,
        int $country_id,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'][0]
    ): array
    {
        $request = $this->restVatLocationsLocationIdCountriesCountryIdGetRequest($location_id, $country_id, $with, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Vat[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Vat[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Vat[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Vat[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Vat[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetAsync
     *
     * List VAT configurations for one country of delivery
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetAsync(
        int $location_id,
        int $country_id,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'][0]
    ): PromiseInterface
    {
        return $this->restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo($location_id, $country_id, $with, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo
     *
     * List VAT configurations for one country of delivery
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo(
        $location_id,
        $country_id,
        $with = null,
        $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Vat[]';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdGetRequest($location_id, $country_id, $with, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdCountriesCountryIdGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetRequest(
        $location_id,
        $country_id,
        $with = null,
        $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdCountriesCountryIdGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdCountriesCountryIdGet'
            );
        }

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restVatLocationsLocationIdCountriesCountryIdGet'
            );
        }




        $resourcePath = '/rest/vat/locations/{locationId}/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with[]', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns[]', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdGet
     *
     * List VAT configurations of an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restVatLocationsLocationIdGet(
        int $location_id,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdGet'][0]
    ): object
    {
        list($response) = $this->restVatLocationsLocationIdGetWithHttpInfo($location_id, $with, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdGetWithHttpInfo
     *
     * List VAT configurations of an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatLocationsLocationIdGetWithHttpInfo(
        int $location_id,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdGet'][0]
    ): array
    {
        $request = $this->restVatLocationsLocationIdGetRequest($location_id, $with, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdGetAsync
     *
     * List VAT configurations of an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatLocationsLocationIdGetAsync(
        int $location_id,
        ?int $with = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restVatLocationsLocationIdGetAsyncWithHttpInfo($location_id, $with, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdGetAsyncWithHttpInfo
     *
     * List VAT configurations of an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatLocationsLocationIdGetAsyncWithHttpInfo(
        $location_id,
        $with = null,
        $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restVatLocationsLocationIdGetRequest($location_id, $with, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int|null $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int|null $columns The attributes of the VAT configuration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatLocationsLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restVatLocationsLocationIdGetRequest(
        $location_id,
        $with = null,
        $columns = null,
        string $contentType = self::contentTypes['restVatLocationsLocationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdGet'
            );
        }




        $resourcePath = '/rest/vat/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with[]', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns[]', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatPost
     *
     * Create a VAT configuration
     *
     * @param  \ck\Model\RestVatPostRequest|null $_rest_vat _rest_vat (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Vat
     */
    public function restVatPost(
        ?\ck\Model\RestVatPostRequest $_rest_vat = null,
        string $contentType = self::contentTypes['restVatPost'][0]
    ): \ck\Model\Vat
    {
        list($response) = $this->restVatPostWithHttpInfo($_rest_vat, $contentType);
        return $response;
    }

    /**
     * Operation restVatPostWithHttpInfo
     *
     * Create a VAT configuration
     *
     * @param  \ck\Model\RestVatPostRequest|null $_rest_vat (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Vat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatPostWithHttpInfo(
        ?\ck\Model\RestVatPostRequest $_rest_vat = null,
        string $contentType = self::contentTypes['restVatPost'][0]
    ): array
    {
        $request = $this->restVatPostRequest($_rest_vat, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Vat' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Vat' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Vat', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Vat';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Vat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatPostAsync
     *
     * Create a VAT configuration
     *
     * @param  \ck\Model\RestVatPostRequest|null $_rest_vat (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatPostAsync(
        ?\ck\Model\RestVatPostRequest $_rest_vat = null,
        string $contentType = self::contentTypes['restVatPost'][0]
    ): PromiseInterface
    {
        return $this->restVatPostAsyncWithHttpInfo($_rest_vat, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatPostAsyncWithHttpInfo
     *
     * Create a VAT configuration
     *
     * @param  \ck\Model\RestVatPostRequest|null $_rest_vat (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatPostAsyncWithHttpInfo(
        $_rest_vat = null,
        string $contentType = self::contentTypes['restVatPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Vat';
        $request = $this->restVatPostRequest($_rest_vat, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatPost'
     *
     * @param  \ck\Model\RestVatPostRequest|null $_rest_vat (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restVatPostRequest(
        $_rest_vat = null,
        string $contentType = self::contentTypes['restVatPost'][0]
    ): Request
    {



        $resourcePath = '/rest/vat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_vat)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_vat));
            } else {
                $httpBody = $_rest_vat;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatStandardGet
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param  int|null $plenty_id The plenty ID of the client (store) (optional)
     * @param  string|null $started_at The date in the W3C format when the vat configuration went into effect (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatStandardGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Vat
     */
    public function restVatStandardGet(
        ?int $plenty_id = null,
        ?string $started_at = null,
        string $contentType = self::contentTypes['restVatStandardGet'][0]
    ): \ck\Model\Vat
    {
        list($response) = $this->restVatStandardGetWithHttpInfo($plenty_id, $started_at, $contentType);
        return $response;
    }

    /**
     * Operation restVatStandardGetWithHttpInfo
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param  int|null $plenty_id The plenty ID of the client (store) (optional)
     * @param  string|null $started_at The date in the W3C format when the vat configuration went into effect (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatStandardGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Vat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatStandardGetWithHttpInfo(
        ?int $plenty_id = null,
        ?string $started_at = null,
        string $contentType = self::contentTypes['restVatStandardGet'][0]
    ): array
    {
        $request = $this->restVatStandardGetRequest($plenty_id, $started_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Vat' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Vat' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Vat', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Vat';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Vat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatStandardGetAsync
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param  int|null $plenty_id The plenty ID of the client (store) (optional)
     * @param  string|null $started_at The date in the W3C format when the vat configuration went into effect (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatStandardGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatStandardGetAsync(
        ?int $plenty_id = null,
        ?string $started_at = null,
        string $contentType = self::contentTypes['restVatStandardGet'][0]
    ): PromiseInterface
    {
        return $this->restVatStandardGetAsyncWithHttpInfo($plenty_id, $started_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatStandardGetAsyncWithHttpInfo
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param  int|null $plenty_id The plenty ID of the client (store) (optional)
     * @param  string|null $started_at The date in the W3C format when the vat configuration went into effect (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatStandardGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatStandardGetAsyncWithHttpInfo(
        $plenty_id = null,
        $started_at = null,
        string $contentType = self::contentTypes['restVatStandardGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Vat';
        $request = $this->restVatStandardGetRequest($plenty_id, $started_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatStandardGet'
     *
     * @param  int|null $plenty_id The plenty ID of the client (store) (optional)
     * @param  string|null $started_at The date in the W3C format when the vat configuration went into effect (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatStandardGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restVatStandardGetRequest(
        $plenty_id = null,
        $started_at = null,
        string $contentType = self::contentTypes['restVatStandardGet'][0]
    ): Request
    {




        $resourcePath = '/rest/vat/standard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $started_at,
            'startedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatVatIdGet
     *
     * Get a VAT configuration by id
     *
     * @param  int $vat_id vat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Vat
     */
    public function restVatVatIdGet(
        int $vat_id,
        string $contentType = self::contentTypes['restVatVatIdGet'][0]
    ): \ck\Model\Vat
    {
        list($response) = $this->restVatVatIdGetWithHttpInfo($vat_id, $contentType);
        return $response;
    }

    /**
     * Operation restVatVatIdGetWithHttpInfo
     *
     * Get a VAT configuration by id
     *
     * @param  int $vat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Vat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatVatIdGetWithHttpInfo(
        int $vat_id,
        string $contentType = self::contentTypes['restVatVatIdGet'][0]
    ): array
    {
        $request = $this->restVatVatIdGetRequest($vat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Vat' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Vat' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Vat', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Vat';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Vat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatVatIdGetAsync
     *
     * Get a VAT configuration by id
     *
     * @param  int $vat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatVatIdGetAsync(
        int $vat_id,
        string $contentType = self::contentTypes['restVatVatIdGet'][0]
    ): PromiseInterface
    {
        return $this->restVatVatIdGetAsyncWithHttpInfo($vat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatVatIdGetAsyncWithHttpInfo
     *
     * Get a VAT configuration by id
     *
     * @param  int $vat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatVatIdGetAsyncWithHttpInfo(
        $vat_id,
        string $contentType = self::contentTypes['restVatVatIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Vat';
        $request = $this->restVatVatIdGetRequest($vat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatVatIdGet'
     *
     * @param  int $vat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restVatVatIdGetRequest(
        $vat_id,
        string $contentType = self::contentTypes['restVatVatIdGet'][0]
    ): Request
    {

        // verify the required parameter 'vat_id' is set
        if ($vat_id === null || (is_array($vat_id) && count($vat_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $vat_id when calling restVatVatIdGet'
            );
        }


        $resourcePath = '/rest/vat/{vatId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vatId' . '}',
                ObjectSerializer::toPathValue($vat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatVatIdPut
     *
     * Update a VAT configuration
     *
     * @param  int $vat_id vat_id (required)
     * @param  \ck\Model\RestVatVatIdPutRequest|null $_rest_vat_vat_id _rest_vat_vat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Vat
     */
    public function restVatVatIdPut(
        int $vat_id,
        ?\ck\Model\RestVatVatIdPutRequest $_rest_vat_vat_id = null,
        string $contentType = self::contentTypes['restVatVatIdPut'][0]
    ): \ck\Model\Vat
    {
        list($response) = $this->restVatVatIdPutWithHttpInfo($vat_id, $_rest_vat_vat_id, $contentType);
        return $response;
    }

    /**
     * Operation restVatVatIdPutWithHttpInfo
     *
     * Update a VAT configuration
     *
     * @param  int $vat_id (required)
     * @param  \ck\Model\RestVatVatIdPutRequest|null $_rest_vat_vat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Vat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatVatIdPutWithHttpInfo(
        int $vat_id,
        ?\ck\Model\RestVatVatIdPutRequest $_rest_vat_vat_id = null,
        string $contentType = self::contentTypes['restVatVatIdPut'][0]
    ): array
    {
        $request = $this->restVatVatIdPutRequest($vat_id, $_rest_vat_vat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Vat' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Vat' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Vat', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Vat';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Vat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatVatIdPutAsync
     *
     * Update a VAT configuration
     *
     * @param  int $vat_id (required)
     * @param  \ck\Model\RestVatVatIdPutRequest|null $_rest_vat_vat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatVatIdPutAsync(
        int $vat_id,
        ?\ck\Model\RestVatVatIdPutRequest $_rest_vat_vat_id = null,
        string $contentType = self::contentTypes['restVatVatIdPut'][0]
    ): PromiseInterface
    {
        return $this->restVatVatIdPutAsyncWithHttpInfo($vat_id, $_rest_vat_vat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatVatIdPutAsyncWithHttpInfo
     *
     * Update a VAT configuration
     *
     * @param  int $vat_id (required)
     * @param  \ck\Model\RestVatVatIdPutRequest|null $_rest_vat_vat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restVatVatIdPutAsyncWithHttpInfo(
        $vat_id,
        $_rest_vat_vat_id = null,
        string $contentType = self::contentTypes['restVatVatIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Vat';
        $request = $this->restVatVatIdPutRequest($vat_id, $_rest_vat_vat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatVatIdPut'
     *
     * @param  int $vat_id (required)
     * @param  \ck\Model\RestVatVatIdPutRequest|null $_rest_vat_vat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restVatVatIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restVatVatIdPutRequest(
        $vat_id,
        $_rest_vat_vat_id = null,
        string $contentType = self::contentTypes['restVatVatIdPut'][0]
    ): Request
    {

        // verify the required parameter 'vat_id' is set
        if ($vat_id === null || (is_array($vat_id) && count($vat_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $vat_id when calling restVatVatIdPut'
            );
        }



        $resourcePath = '/rest/vat/{vatId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vatId' . '}',
                ObjectSerializer::toPathValue($vat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_vat_vat_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_vat_vat_id));
            } else {
                $httpBody = $_rest_vat_vat_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
