<?php
/**
 * DocumentApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * DocumentApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DocumentApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restCategoriesCategoryIdDocumentsDocumentIdDelete' => [
            'application/json',
        ],
        'restCategoriesCategoryIdDocumentsDownloadsGet' => [
            'application/json',
        ],
        'restCategoriesCategoryIdDocumentsGet' => [
            'application/json',
        ],
        'restCategoriesCategoryIdDocumentsPost' => [
            'application/json',
        ],
        'restDocumentsDocumentIdGet' => [
            'application/json',
        ],
        'restOrdersDocumentsDownloadsTypeGet' => [
            'application/json',
        ],
        'restOrdersDocumentsGet' => [
            'application/json',
        ],
        'restOrdersDocumentsTypeGet' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsCreditNoteGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsDeliveryNoteGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsDocumentIdDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsDunningLetterGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsInvoiceGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsOfferGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsOrderConfirmationGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsPickupDeliveryGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsReorderGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsRepairBillGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsReturnNoteGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsReversalDocumentGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsReversalRefundGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsTypeCurrentGet' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsTypeGeneratePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsTypePost' => [
            'application/json',
        ],
        'restOrdersOrderIdDocumentsTypeRecentGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDelete
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id category_id (required)
     * @param  int $document_id document_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDelete(
        int $category_id,
        int $document_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'][0]
    ): object
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo($category_id, $document_id, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo(
        int $category_id,
        int $document_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'][0]
    ): array
    {
        $request = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest($category_id, $document_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteAsync
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteAsync(
        int $category_id,
        int $document_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($category_id, $document_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo(
        $category_id,
        $document_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest($category_id, $document_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsDocumentIdDelete'
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest(
        $category_id,
        $document_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDocumentIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsDocumentIdDelete'
            );
        }

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $document_id when calling restCategoriesCategoryIdDocumentsDocumentIdDelete'
            );
        }


        $resourcePath = '/rest/categories/{categoryId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGet
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGet(
        int $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'][0]
    ): object
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo($category_id, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo(
        int $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'][0]
    ): array
    {
        $request = $this->restCategoriesCategoryIdDocumentsDownloadsGetRequest($category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetAsync
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetAsync(
        int $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo($category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo(
        $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restCategoriesCategoryIdDocumentsDownloadsGetRequest($category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsDownloadsGet'
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetRequest(
        $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsDownloadsGet'][0]
    ): Request
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsDownloadsGet'
            );
        }


        $resourcePath = '/rest/categories/{categoryId}/documents/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGet
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response
     */
    public function restCategoriesCategoryIdDocumentsGet(
        int $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsGet'][0]
    ): \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsGetWithHttpInfo($category_id, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetWithHttpInfo
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsGetWithHttpInfo(
        int $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsGet'][0]
    ): array
    {
        $request = $this->restCategoriesCategoryIdDocumentsGetRequest($category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetAsync
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsGetAsync(
        int $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsGet'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo($category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo(
        $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response';
        $request = $this->restCategoriesCategoryIdDocumentsGetRequest($category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsGet'
     *
     * @param  int $category_id The ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesCategoryIdDocumentsGetRequest(
        $category_id,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsGet'][0]
    ): Request
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsGet'
            );
        }


        $resourcePath = '/rest/categories/{categoryId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPost
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int|null $number The document number (optional)
     * @param  string|null $number_with_prefix Number with prefix (optional)
     * @param  int|null $directory_id The directory ID (optional)
     * @param  string|null $display_date The date displayed on the document (optional)
     * @param  \ck\Model\RestCategoriesCategoryIdDocumentsPostRequest|null $_rest_categories_category_id_documents _rest_categories_category_id_documents (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Document[]
     */
    public function restCategoriesCategoryIdDocumentsPost(
        int $documents,
        int $category_id,
        ?int $number = null,
        ?string $number_with_prefix = null,
        ?int $directory_id = null,
        ?string $display_date = null,
        ?\ck\Model\RestCategoriesCategoryIdDocumentsPostRequest $_rest_categories_category_id_documents = null,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsPost'][0]
    ): array
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsPostWithHttpInfo($documents, $category_id, $number, $number_with_prefix, $directory_id, $display_date, $_rest_categories_category_id_documents, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostWithHttpInfo
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int|null $number The document number (optional)
     * @param  string|null $number_with_prefix Number with prefix (optional)
     * @param  int|null $directory_id The directory ID (optional)
     * @param  string|null $display_date The date displayed on the document (optional)
     * @param  \ck\Model\RestCategoriesCategoryIdDocumentsPostRequest|null $_rest_categories_category_id_documents (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Document[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsPostWithHttpInfo(
        int $documents,
        int $category_id,
        ?int $number = null,
        ?string $number_with_prefix = null,
        ?int $directory_id = null,
        ?string $display_date = null,
        ?\ck\Model\RestCategoriesCategoryIdDocumentsPostRequest $_rest_categories_category_id_documents = null,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsPost'][0]
    ): array
    {
        $request = $this->restCategoriesCategoryIdDocumentsPostRequest($documents, $category_id, $number, $number_with_prefix, $directory_id, $display_date, $_rest_categories_category_id_documents, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Document[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Document[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Document[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Document[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostAsync
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int|null $number The document number (optional)
     * @param  string|null $number_with_prefix Number with prefix (optional)
     * @param  int|null $directory_id The directory ID (optional)
     * @param  string|null $display_date The date displayed on the document (optional)
     * @param  \ck\Model\RestCategoriesCategoryIdDocumentsPostRequest|null $_rest_categories_category_id_documents (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsPostAsync(
        int $documents,
        int $category_id,
        ?int $number = null,
        ?string $number_with_prefix = null,
        ?int $directory_id = null,
        ?string $display_date = null,
        ?\ck\Model\RestCategoriesCategoryIdDocumentsPostRequest $_rest_categories_category_id_documents = null,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsPost'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo($documents, $category_id, $number, $number_with_prefix, $directory_id, $display_date, $_rest_categories_category_id_documents, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int|null $number The document number (optional)
     * @param  string|null $number_with_prefix Number with prefix (optional)
     * @param  int|null $directory_id The directory ID (optional)
     * @param  string|null $display_date The date displayed on the document (optional)
     * @param  \ck\Model\RestCategoriesCategoryIdDocumentsPostRequest|null $_rest_categories_category_id_documents (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo(
        $documents,
        $category_id,
        $number = null,
        $number_with_prefix = null,
        $directory_id = null,
        $display_date = null,
        $_rest_categories_category_id_documents = null,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Document[]';
        $request = $this->restCategoriesCategoryIdDocumentsPostRequest($documents, $category_id, $number, $number_with_prefix, $directory_id, $display_date, $_rest_categories_category_id_documents, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsPost'
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  int|null $number The document number (optional)
     * @param  string|null $number_with_prefix Number with prefix (optional)
     * @param  int|null $directory_id The directory ID (optional)
     * @param  string|null $display_date The date displayed on the document (optional)
     * @param  \ck\Model\RestCategoriesCategoryIdDocumentsPostRequest|null $_rest_categories_category_id_documents (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesCategoryIdDocumentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesCategoryIdDocumentsPostRequest(
        $documents,
        $category_id,
        $number = null,
        $number_with_prefix = null,
        $directory_id = null,
        $display_date = null,
        $_rest_categories_category_id_documents = null,
        string $contentType = self::contentTypes['restCategoriesCategoryIdDocumentsPost'][0]
    ): Request
    {

        // verify the required parameter 'documents' is set
        if ($documents === null || (is_array($documents) && count($documents) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $documents when calling restCategoriesCategoryIdDocumentsPost'
            );
        }

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsPost'
            );
        }







        $resourcePath = '/rest/categories/{categoryId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $documents,
            'documents', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number_with_prefix,
            'numberWithPrefix', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $directory_id,
            'directoryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_date,
            'displayDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_categories_category_id_documents)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_categories_category_id_documents));
            } else {
                $httpBody = $_rest_categories_category_id_documents;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restDocumentsDocumentIdGet
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDocumentsDocumentIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restDocumentsDocumentIdGet(
        int $document_id,
        string $contentType = self::contentTypes['restDocumentsDocumentIdGet'][0]
    ): object
    {
        list($response) = $this->restDocumentsDocumentIdGetWithHttpInfo($document_id, $contentType);
        return $response;
    }

    /**
     * Operation restDocumentsDocumentIdGetWithHttpInfo
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDocumentsDocumentIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDocumentsDocumentIdGetWithHttpInfo(
        int $document_id,
        string $contentType = self::contentTypes['restDocumentsDocumentIdGet'][0]
    ): array
    {
        $request = $this->restDocumentsDocumentIdGetRequest($document_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDocumentsDocumentIdGetAsync
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDocumentsDocumentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restDocumentsDocumentIdGetAsync(
        int $document_id,
        string $contentType = self::contentTypes['restDocumentsDocumentIdGet'][0]
    ): PromiseInterface
    {
        return $this->restDocumentsDocumentIdGetAsyncWithHttpInfo($document_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDocumentsDocumentIdGetAsyncWithHttpInfo
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDocumentsDocumentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restDocumentsDocumentIdGetAsyncWithHttpInfo(
        $document_id,
        string $contentType = self::contentTypes['restDocumentsDocumentIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restDocumentsDocumentIdGetRequest($document_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDocumentsDocumentIdGet'
     *
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDocumentsDocumentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restDocumentsDocumentIdGetRequest(
        $document_id,
        string $contentType = self::contentTypes['restDocumentsDocumentIdGet'][0]
    ): Request
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $document_id when calling restDocumentsDocumentIdGet'
            );
        }


        $resourcePath = '/rest/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGet
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsDownloadsTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersDocumentsDownloadsTypeGet(
        string $type,
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        string $contentType = self::contentTypes['restOrdersDocumentsDownloadsTypeGet'][0]
    ): object
    {
        list($response) = $this->restOrdersDocumentsDownloadsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetWithHttpInfo
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsDownloadsTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsDownloadsTypeGetWithHttpInfo(
        string $type,
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        string $contentType = self::contentTypes['restOrdersDocumentsDownloadsTypeGet'][0]
    ): array
    {
        $request = $this->restOrdersDocumentsDownloadsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetAsync
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsDownloadsTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDocumentsDownloadsTypeGetAsync(
        string $type,
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        string $contentType = self::contentTypes['restOrdersDocumentsDownloadsTypeGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsDownloadsTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo(
        $type,
        $page,
        $items_per_page,
        $contact_id = null,
        $plenty_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $display_date_from = null,
        $display_date_to = null,
        string $contentType = self::contentTypes['restOrdersDocumentsDownloadsTypeGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersDocumentsDownloadsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsDownloadsTypeGet'
     *
     * @param  string $type The type of the order document. The available types are receipt, zReport, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsDownloadsTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersDocumentsDownloadsTypeGetRequest(
        $type,
        $page,
        $items_per_page,
        $contact_id = null,
        $plenty_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $display_date_from = null,
        $display_date_to = null,
        string $contentType = self::contentTypes['restOrdersDocumentsDownloadsTypeGet'][0]
    ): Request
    {

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }

        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }










        $resourcePath = '/rest/orders/documents/downloads/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_id,
            'contactId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_from,
            'createdAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_to,
            'createdAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_from,
            'updatedAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_to,
            'updatedAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_date_from,
            'displayDateFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_date_to,
            'displayDateTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsGet
     *
     * List order documents
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response
     */
    public function restOrdersDocumentsGet(
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        ?int $with = null,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsGet'][0]
    ): \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response
    {
        list($response) = $this->restOrdersDocumentsGetWithHttpInfo($page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsGetWithHttpInfo
     *
     * List order documents
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsGetWithHttpInfo(
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        ?int $with = null,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsGet'][0]
    ): array
    {
        $request = $this->restOrdersDocumentsGetRequest($page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsGetAsync
     *
     * List order documents
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDocumentsGetAsync(
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        ?int $with = null,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersDocumentsGetAsyncWithHttpInfo($page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsGetAsyncWithHttpInfo
     *
     * List order documents
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDocumentsGetAsyncWithHttpInfo(
        $page,
        $items_per_page,
        $contact_id = null,
        $plenty_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $display_date_from = null,
        $display_date_to = null,
        $with = null,
        $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response';
        $request = $this->restOrdersDocumentsGetRequest($page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsGet'
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersDocumentsGetRequest(
        $page,
        $items_per_page,
        $contact_id = null,
        $plenty_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $display_date_from = null,
        $display_date_to = null,
        $with = null,
        $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsGet'][0]
    ): Request
    {

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersDocumentsGet'
            );
        }

        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersDocumentsGet'
            );
        }










        $resourcePath = '/rest/orders/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_id,
            'contactId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_from,
            'createdAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_to,
            'createdAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_date_from,
            'displayDateFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_date_to,
            'displayDateTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_content,
            'withContent', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsTypeGet
     *
     * List documents of a type
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response
     */
    public function restOrdersDocumentsTypeGet(
        string $type,
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        ?int $with = null,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsTypeGet'][0]
    ): \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response
    {
        list($response) = $this->restOrdersDocumentsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $with, $with_content, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsTypeGetWithHttpInfo
     *
     * List documents of a type
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestCategoriesCategoryIdDocumentsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsTypeGetWithHttpInfo(
        string $type,
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        ?int $with = null,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsTypeGet'][0]
    ): array
    {
        $request = $this->restOrdersDocumentsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $with, $with_content, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsTypeGetAsync
     *
     * List documents of a type
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDocumentsTypeGetAsync(
        string $type,
        int $page,
        int $items_per_page,
        ?int $contact_id = null,
        ?int $plenty_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $display_date_from = null,
        ?string $display_date_to = null,
        ?int $with = null,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsTypeGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersDocumentsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $with, $with_content, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsTypeGetAsyncWithHttpInfo
     *
     * List documents of a type
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDocumentsTypeGetAsyncWithHttpInfo(
        $type,
        $page,
        $items_per_page,
        $contact_id = null,
        $plenty_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $display_date_from = null,
        $display_date_to = null,
        $with = null,
        $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsTypeGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestCategoriesCategoryIdDocumentsGet200Response';
        $request = $this->restOrdersDocumentsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $updated_at_from, $updated_at_to, $display_date_from, $display_date_to, $with, $with_content, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsTypeGet'
     *
     * @param  string $type The type of the order document. The available types are receipt, tillCount, posCouponReceipt, posInvoice, posInvoiceCancellation, cancellation, zReport, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice, reorder, uploaded. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int|null $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int|null $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to documents that were updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to documents that were updated within a certain period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;references&#39; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersDocumentsTypeGetRequest(
        $type,
        $page,
        $items_per_page,
        $contact_id = null,
        $plenty_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $display_date_from = null,
        $display_date_to = null,
        $with = null,
        $with_content = null,
        string $contentType = self::contentTypes['restOrdersDocumentsTypeGet'][0]
    ): Request
    {

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersDocumentsTypeGet'
            );
        }

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersDocumentsTypeGet'
            );
        }

        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersDocumentsTypeGet'
            );
        }












        $resourcePath = '/rest/orders/documents/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_id,
            'contactId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_from,
            'createdAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_to,
            'createdAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_from,
            'updatedAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_to,
            'updatedAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_date_from,
            'displayDateFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_date_to,
            'displayDateTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_content,
            'withContent', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost
     *
     * Generate adjustment form of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostWithHttpInfo
     *
     * Generate adjustment form of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsync
     *
     * Generate adjustment form of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsyncWithHttpInfo
     *
     * Generate adjustment form of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsCorrectionDocumentGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsCorrectionDocumentGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/correction_document/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsCreditNoteGeneratePost
     *
     * Generate credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool|null $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsCreditNoteGeneratePostWithHttpInfo($order_id, $document_date, $allow_regenerate, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsCreditNoteGeneratePostWithHttpInfo
     *
     * Generate credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool|null $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsCreditNoteGeneratePostRequest($order_id, $document_date, $allow_regenerate, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsCreditNoteGeneratePostAsync
     *
     * Generate credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool|null $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsCreditNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date, $allow_regenerate, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsCreditNoteGeneratePostAsyncWithHttpInfo
     *
     * Generate credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool|null $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $allow_regenerate = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsCreditNoteGeneratePostRequest($order_id, $document_date, $allow_regenerate, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsCreditNoteGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39; (optional)
     * @param  bool|null $allow_regenerate If true, existing credit not document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsCreditNoteGeneratePostRequest(
        $order_id,
        $document_date = null,
        $allow_regenerate = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsCreditNoteGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsCreditNoteGeneratePost'
            );
        }





        $resourcePath = '/rest/orders/{orderId}/documents/credit_note/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_regenerate,
            'allowRegenerate', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDeliveryNoteGeneratePost
     *
     * Generate delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?int $storehouse_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsDeliveryNoteGeneratePostWithHttpInfo($order_id, $document_date, $comment, $storehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsDeliveryNoteGeneratePostWithHttpInfo
     *
     * Generate delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?int $storehouse_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsDeliveryNoteGeneratePostRequest($order_id, $document_date, $comment, $storehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsync
     *
     * Generate delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?int $storehouse_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $storehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsyncWithHttpInfo
     *
     * Generate delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        $storehouse_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsDeliveryNoteGeneratePostRequest($order_id, $document_date, $comment, $storehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $storehouse_id If set, only items with the given warehouse ID are included on the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsDeliveryNoteGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        $storehouse_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsDeliveryNoteGeneratePost'
            );
        }





        $resourcePath = '/rest/orders/{orderId}/documents/delivery_note/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $storehouse_id,
            'storehouseId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDelete
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsDocumentIdDelete(
        int $order_id,
        int $document_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo($order_id, $document_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo(
        int $order_id,
        int $document_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsDocumentIdDeleteRequest($order_id, $document_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteAsync
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteAsync(
        int $order_id,
        int $document_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($order_id, $document_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo(
        $order_id,
        $document_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsDocumentIdDeleteRequest($order_id, $document_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsDocumentIdDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteRequest(
        $order_id,
        $document_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDocumentIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsDocumentIdDelete'
            );
        }

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $document_id when calling restOrdersOrderIdDocumentsDocumentIdDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDunningLetterGeneratePost
     *
     * Generate dunning letter of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $article_id Add an item to the order. (optional)
     * @param  int|null $variation_id Add a variation to the order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?int $article_id = null,
        ?int $variation_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsDunningLetterGeneratePostWithHttpInfo($order_id, $document_date, $comment, $article_id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsDunningLetterGeneratePostWithHttpInfo
     *
     * Generate dunning letter of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $article_id Add an item to the order. (optional)
     * @param  int|null $variation_id Add a variation to the order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?int $article_id = null,
        ?int $variation_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsDunningLetterGeneratePostRequest($order_id, $document_date, $comment, $article_id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsDunningLetterGeneratePostAsync
     *
     * Generate dunning letter of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $article_id Add an item to the order. (optional)
     * @param  int|null $variation_id Add a variation to the order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?int $article_id = null,
        ?int $variation_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsDunningLetterGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $article_id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDunningLetterGeneratePostAsyncWithHttpInfo
     *
     * Generate dunning letter of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $article_id Add an item to the order. (optional)
     * @param  int|null $variation_id Add a variation to the order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        $article_id = null,
        $variation_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsDunningLetterGeneratePostRequest($order_id, $document_date, $comment, $article_id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsDunningLetterGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  int|null $article_id Add an item to the order. (optional)
     * @param  int|null $variation_id Add a variation to the order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsDunningLetterGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        $article_id = null,
        $variation_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsDunningLetterGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsDunningLetterGeneratePost'
            );
        }






        $resourcePath = '/rest/orders/{orderId}/documents/dunning_letter/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $article_id,
            'articleId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_id,
            'variationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsInvoiceGeneratePost
     *
     * Generate invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool|null $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsInvoiceGeneratePostWithHttpInfo($order_id, $document_date, $allow_regenerate, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsInvoiceGeneratePostWithHttpInfo
     *
     * Generate invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool|null $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsInvoiceGeneratePostRequest($order_id, $document_date, $allow_regenerate, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsInvoiceGeneratePostAsync
     *
     * Generate invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool|null $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsInvoiceGeneratePostAsyncWithHttpInfo($order_id, $document_date, $allow_regenerate, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsInvoiceGeneratePostAsyncWithHttpInfo
     *
     * Generate invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool|null $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $allow_regenerate = null,
        $comment = null,
        $valuta = null,
        $discount = null,
        $discount_percentage = null,
        $discount_days = null,
        $payment_due = null,
        $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsInvoiceGeneratePostRequest($order_id, $document_date, $allow_regenerate, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsInvoiceGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  bool|null $allow_regenerate If true, existing invoice document without reversal is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsInvoiceGeneratePostRequest(
        $order_id,
        $document_date = null,
        $allow_regenerate = null,
        $comment = null,
        $valuta = null,
        $discount = null,
        $discount_percentage = null,
        $discount_days = null,
        $payment_due = null,
        $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsInvoiceGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsInvoiceGeneratePost'
            );
        }











        $resourcePath = '/rest/orders/{orderId}/documents/invoice/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_regenerate,
            'allowRegenerate', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $valuta,
            'valuta', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount,
            'discount', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount_percentage,
            'discountPercentage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount_days,
            'discountDays', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_due,
            'paymentDue', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_due_days,
            'paymentDueDays', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsOfferGeneratePost
     *
     * Generate offer document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsOfferGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsOfferGeneratePostWithHttpInfo
     *
     * Generate offer document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsOfferGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsOfferGeneratePostAsync
     *
     * Generate offer document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsOfferGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsOfferGeneratePostAsyncWithHttpInfo
     *
     * Generate offer document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsOfferGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsOfferGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsOfferGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOfferGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsOfferGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/offer/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsOrderConfirmationGeneratePost
     *
     * Generate order confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsOrderConfirmationGeneratePostWithHttpInfo($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsOrderConfirmationGeneratePostWithHttpInfo
     *
     * Generate order confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsOrderConfirmationGeneratePostRequest($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsync
     *
     * Generate order confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsyncWithHttpInfo
     *
     * Generate order confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        $valuta = null,
        $discount = null,
        $discount_percentage = null,
        $discount_days = null,
        $payment_due = null,
        $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsOrderConfirmationGeneratePostRequest($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsOrderConfirmationGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        $valuta = null,
        $discount = null,
        $discount_percentage = null,
        $discount_days = null,
        $payment_due = null,
        $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsOrderConfirmationGeneratePost'
            );
        }










        $resourcePath = '/rest/orders/{orderId}/documents/order_confirmation/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $valuta,
            'valuta', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount,
            'discount', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount_percentage,
            'discountPercentage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount_days,
            'discountDays', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_due,
            'paymentDue', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_due_days,
            'paymentDueDays', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsPickupDeliveryGeneratePost
     *
     * Generate pick-up delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsPickupDeliveryGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsPickupDeliveryGeneratePostWithHttpInfo
     *
     * Generate pick-up delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsPickupDeliveryGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsync
     *
     * Generate pick-up delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsyncWithHttpInfo
     *
     * Generate pick-up delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsPickupDeliveryGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsPickupDeliveryGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsPickupDeliveryGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/pickup_delivery/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost
     *
     * Generate purchase order (PO) delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost(
        int $order_id,
        ?string $document_date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostWithHttpInfo($order_id, $document_date, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostWithHttpInfo
     *
     * Generate purchase order (PO) delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostRequest($order_id, $document_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsync
     *
     * Generate purchase order (PO) delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsyncWithHttpInfo
     *
     * Generate purchase order (PO) delivery note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostRequest($order_id, $document_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePostRequest(
        $order_id,
        $document_date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsPoDeliveryNoteGeneratePost'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/documents/po_delivery_note/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost
     *
     * Generate pro forma invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostWithHttpInfo($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostWithHttpInfo
     *
     * Generate pro forma invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostRequest($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsync
     *
     * Generate pro forma invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        ?bool $valuta = null,
        ?bool $discount = null,
        ?int $discount_percentage = null,
        ?int $discount_days = null,
        ?bool $payment_due = null,
        ?int $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsyncWithHttpInfo
     *
     * Generate pro forma invoice of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        $valuta = null,
        $discount = null,
        $discount_percentage = null,
        $discount_days = null,
        $payment_due = null,
        $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostRequest($order_id, $document_date, $comment, $valuta, $discount, $discount_percentage, $discount_days, $payment_due, $payment_due_days, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  bool|null $valuta If true, valuta is enabled. (optional)
     * @param  bool|null $discount If true, discount is enabled for the document. (optional)
     * @param  int|null $discount_percentage Overwrite percentage discount value. Possible values are 2, 3, 4, 5. (optional)
     * @param  int|null $discount_days Overwrite discount in days. Possible values are 1, 5, 7, 10, 14, 21, 28, 30, 60, 90. (optional)
     * @param  bool|null $payment_due If true, payment due is enabled. (optional)
     * @param  int|null $payment_due_days Overwrite payment due in days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsProFormaInvoiceGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        $valuta = null,
        $discount = null,
        $discount_percentage = null,
        $discount_days = null,
        $payment_due = null,
        $payment_due_days = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsProFormaInvoiceGeneratePost'
            );
        }










        $resourcePath = '/rest/orders/{orderId}/documents/pro_forma_invoice/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $valuta,
            'valuta', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount,
            'discount', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount_percentage,
            'discountPercentage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $discount_days,
            'discountDays', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_due,
            'paymentDue', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_due_days,
            'paymentDueDays', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReorderGeneratePost
     *
     * Generate reorder document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool|null $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePost(
        int $order_id,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsReorderGeneratePostWithHttpInfo($order_id, $allow_regenerate, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReorderGeneratePostWithHttpInfo
     *
     * Generate reorder document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool|null $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePostWithHttpInfo(
        int $order_id,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsReorderGeneratePostRequest($order_id, $allow_regenerate, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReorderGeneratePostAsync
     *
     * Generate reorder document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool|null $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePostAsync(
        int $order_id,
        ?bool $allow_regenerate = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsReorderGeneratePostAsyncWithHttpInfo($order_id, $allow_regenerate, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReorderGeneratePostAsyncWithHttpInfo
     *
     * Generate reorder document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool|null $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePostAsyncWithHttpInfo(
        $order_id,
        $allow_regenerate = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReorderGeneratePostRequest($order_id, $allow_regenerate, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReorderGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  bool|null $allow_regenerate If true, existing reorder document is generated once again. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsReorderGeneratePostRequest(
        $order_id,
        $allow_regenerate = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReorderGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReorderGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/reorder/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_regenerate,
            'allowRegenerate', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsRepairBillGeneratePost
     *
     * Generate repair slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsRepairBillGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsRepairBillGeneratePostWithHttpInfo
     *
     * Generate repair slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsRepairBillGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsRepairBillGeneratePostAsync
     *
     * Generate repair slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsRepairBillGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsRepairBillGeneratePostAsyncWithHttpInfo
     *
     * Generate repair slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsRepairBillGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsRepairBillGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsRepairBillGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsRepairBillGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsRepairBillGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/repair_bill/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReturnNoteGeneratePost
     *
     * Generate return slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsReturnNoteGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReturnNoteGeneratePostWithHttpInfo
     *
     * Generate return slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsReturnNoteGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReturnNoteGeneratePostAsync
     *
     * Generate return slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsReturnNoteGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReturnNoteGeneratePostAsyncWithHttpInfo
     *
     * Generate return slip of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReturnNoteGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReturnNoteGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsReturnNoteGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReturnNoteGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReturnNoteGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/return_note/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDocumentGeneratePost
     *
     * Generate reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsReversalDocumentGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDocumentGeneratePostWithHttpInfo
     *
     * Generate reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsReversalDocumentGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsync
     *
     * Generate reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsyncWithHttpInfo
     *
     * Generate reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReversalDocumentGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReversalDocumentGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsReversalDocumentGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDocumentGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReversalDocumentGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/reversal_document/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost
     *
     * Generate dunning letter reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostWithHttpInfo
     *
     * Generate dunning letter reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsync
     *
     * Generate dunning letter reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsyncWithHttpInfo
     *
     * Generate dunning letter reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsReversalDunningLetterGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReversalDunningLetterGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/reversal_dunning_letter/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalRefundGeneratePost
     *
     * Generate refund reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsReversalRefundGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalRefundGeneratePostWithHttpInfo
     *
     * Generate refund reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsReversalRefundGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalRefundGeneratePostAsync
     *
     * Generate refund reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsReversalRefundGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsReversalRefundGeneratePostAsyncWithHttpInfo
     *
     * Generate refund reversal document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsReversalRefundGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsReversalRefundGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsReversalRefundGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsReversalRefundGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsReversalRefundGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/reversal_refund/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost
     *
     * Generate success confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostWithHttpInfo($order_id, $document_date, $comment, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostWithHttpInfo
     *
     * Generate success confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostWithHttpInfo(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsync
     *
     * Generate success confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsync(
        int $order_id,
        ?string $document_date = null,
        ?string $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsyncWithHttpInfo($order_id, $document_date, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsyncWithHttpInfo
     *
     * Generate success confirmation of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostAsyncWithHttpInfo(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostRequest($order_id, $document_date, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $document_date If not set, the current date will be used. The date has to be entered in W3C format, e.g. &#39;2019-05-29T13:33:23+02:00&#39;. (optional)
     * @param  string|null $comment Comment that appears below the stock units. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsSuccessConfirmationGeneratePostRequest(
        $order_id,
        $document_date = null,
        $comment = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsSuccessConfirmationGeneratePost'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/documents/success_confirmation/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date,
            'documentDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeCurrentGet
     *
     * Get current invoice or credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Document
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGet(
        int $order_id,
        string $type,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'][0]
    ): \ck\Model\Document
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypeCurrentGetWithHttpInfo($order_id, $type, $with_content, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeCurrentGetWithHttpInfo
     *
     * Get current invoice or credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGetWithHttpInfo(
        int $order_id,
        string $type,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsTypeCurrentGetRequest($order_id, $type, $with_content, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Document' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Document' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Document', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Document';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeCurrentGetAsync
     *
     * Get current invoice or credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGetAsync(
        int $order_id,
        string $type,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsTypeCurrentGetAsyncWithHttpInfo($order_id, $type, $with_content, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeCurrentGetAsyncWithHttpInfo
     *
     * Get current invoice or credit note of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGetAsyncWithHttpInfo(
        $order_id,
        $type,
        $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Document';
        $request = $this->restOrdersOrderIdDocumentsTypeCurrentGetRequest($order_id, $type, $with_content, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypeCurrentGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are invoice, creditNote, dunningLetter (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsTypeCurrentGetRequest(
        $order_id,
        $type,
        $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeCurrentGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypeCurrentGet'
            );
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypeCurrentGet'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/documents/{type}/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_content,
            'withContent', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePost
     *
     * Generate document of an order
     *
     * @param  int $order_id order_id (required)
     * @param  int $type type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePost(
        int $order_id,
        int $type,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo($order_id, $type, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo
     *
     * Generate document of an order
     *
     * @param  int $order_id (required)
     * @param  int $type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo(
        int $order_id,
        int $type,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsTypeGeneratePostRequest($order_id, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostAsync
     *
     * Generate document of an order
     *
     * @param  int $order_id (required)
     * @param  int $type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostAsync(
        int $order_id,
        int $type,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo($order_id, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo
     *
     * Generate document of an order
     *
     * @param  int $order_id (required)
     * @param  int $type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo(
        $order_id,
        $type,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsTypeGeneratePostRequest($order_id, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypeGeneratePost'
     *
     * @param  int $order_id (required)
     * @param  int $type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostRequest(
        $order_id,
        $type,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeGeneratePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypeGeneratePost'
            );
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypeGeneratePost'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/documents/{type}/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePost
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \ck\Model\RestOrdersOrderIdDocumentsTypePostRequest|null $_rest_orders_order_id_documents_type _rest_orders_order_id_documents_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Document[]
     */
    public function restOrdersOrderIdDocumentsTypePost(
        int $order_id,
        string $type,
        ?\ck\Model\RestOrdersOrderIdDocumentsTypePostRequest $_rest_orders_order_id_documents_type = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypePost'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypePostWithHttpInfo($order_id, $type, $_rest_orders_order_id_documents_type, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostWithHttpInfo
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \ck\Model\RestOrdersOrderIdDocumentsTypePostRequest|null $_rest_orders_order_id_documents_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Document[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypePostWithHttpInfo(
        int $order_id,
        string $type,
        ?\ck\Model\RestOrdersOrderIdDocumentsTypePostRequest $_rest_orders_order_id_documents_type = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypePost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsTypePostRequest($order_id, $type, $_rest_orders_order_id_documents_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Document[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Document[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Document[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Document[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostAsync
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \ck\Model\RestOrdersOrderIdDocumentsTypePostRequest|null $_rest_orders_order_id_documents_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypePostAsync(
        int $order_id,
        string $type,
        ?\ck\Model\RestOrdersOrderIdDocumentsTypePostRequest $_rest_orders_order_id_documents_type = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypePost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo($order_id, $type, $_rest_orders_order_id_documents_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \ck\Model\RestOrdersOrderIdDocumentsTypePostRequest|null $_rest_orders_order_id_documents_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo(
        $order_id,
        $type,
        $_rest_orders_order_id_documents_type = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypePost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Document[]';
        $request = $this->restOrdersOrderIdDocumentsTypePostRequest($order_id, $type, $_rest_orders_order_id_documents_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#39;invoiceExternal&#39;, &#39;deliveryNote&#39;, &#39;poDeliveryNote&#39;, &#39;orderConfirmation&#39;, &#39;offer&#39;, &#39;dunningLetter&#39;, &#39;reversalDunningLetter&#39;, &#39;returnNote&#39;, &#39;successConfirmation&#39;, &#39;correction&#39;, &#39;creditNoteExternal&#39;, &#39;reorder&#39;, &#39;uploaded&#39;. (required)
     * @param  \ck\Model\RestOrdersOrderIdDocumentsTypePostRequest|null $_rest_orders_order_id_documents_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsTypePostRequest(
        $order_id,
        $type,
        $_rest_orders_order_id_documents_type = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypePost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypePost'
            );
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypePost'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/documents/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id_documents_type)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id_documents_type));
            } else {
                $httpBody = $_rest_orders_order_id_documents_type;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeRecentGet
     *
     * Get most recent document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Document
     */
    public function restOrdersOrderIdDocumentsTypeRecentGet(
        int $order_id,
        string $type,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'][0]
    ): \ck\Model\Document
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypeRecentGetWithHttpInfo($order_id, $type, $with_content, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeRecentGetWithHttpInfo
     *
     * Get most recent document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypeRecentGetWithHttpInfo(
        int $order_id,
        string $type,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDocumentsTypeRecentGetRequest($order_id, $type, $with_content, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Document' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Document' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Document', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Document';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeRecentGetAsync
     *
     * Get most recent document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeRecentGetAsync(
        int $order_id,
        string $type,
        ?bool $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDocumentsTypeRecentGetAsyncWithHttpInfo($order_id, $type, $with_content, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeRecentGetAsyncWithHttpInfo
     *
     * Get most recent document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeRecentGetAsyncWithHttpInfo(
        $order_id,
        $type,
        $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Document';
        $request = $this->restOrdersOrderIdDocumentsTypeRecentGetRequest($order_id, $type, $with_content, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypeRecentGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order document. The available types are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, reversalDunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, . (required)
     * @param  bool|null $with_content Load also the document content as base64 encoded string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDocumentsTypeRecentGetRequest(
        $order_id,
        $type,
        $with_content = null,
        string $contentType = self::contentTypes['restOrdersOrderIdDocumentsTypeRecentGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypeRecentGet'
            );
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypeRecentGet'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/documents/{type}/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_content,
            'withContent', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
