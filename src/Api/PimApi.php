<?php
/**
 * PimApi
 * PHP version 8.1
 *
 * @package  ck/plenty-client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck/plenty-client\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck/plenty-client\ApiException;
use ck/plenty-client\Configuration;
use ck/plenty-client\HeaderSelector;
use ck/plenty-client\ObjectSerializer;

/**
 * PimApi Class Doc Comment
 *
 * @package  ck/plenty-client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PimApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restPimAttributesDelete' => [
            'application/json',
        ],
        'restPimAttributesGet' => [
            'application/json',
        ],
        'restPimAttributesIdGet' => [
            'application/json',
        ],
        'restPimAttributesNamesDelete' => [
            'application/json',
        ],
        'restPimAttributesNamesGet' => [
            'application/json',
        ],
        'restPimAttributesNamesPost' => [
            'application/json',
        ],
        'restPimAttributesNamesPut' => [
            'application/json',
        ],
        'restPimAttributesPost' => [
            'application/json',
        ],
        'restPimAttributesPut' => [
            'application/json',
        ],
        'restPimAttributesValuesDelete' => [
            'application/json',
        ],
        'restPimAttributesValuesGet' => [
            'application/json',
        ],
        'restPimAttributesValuesIdGet' => [
            'application/json',
        ],
        'restPimAttributesValuesNamesDelete' => [
            'application/json',
        ],
        'restPimAttributesValuesNamesGet' => [
            'application/json',
        ],
        'restPimAttributesValuesNamesPost' => [
            'application/json',
        ],
        'restPimAttributesValuesNamesPut' => [
            'application/json',
        ],
        'restPimAttributesValuesPost' => [
            'application/json',
        ],
        'restPimAttributesValuesPut' => [
            'application/json',
        ],
        'restPimCategoriesBranchesGet' => [
            'application/json',
        ],
        'restPimCategoriesClientsGet' => [
            'application/json',
        ],
        'restPimCategoriesDetailsGet' => [
            'application/json',
        ],
        'restPimCategoriesGet' => [
            'application/json',
        ],
        'restPimCategoriesIdGet' => [
            'application/json',
        ],
        'restPimCategoriesPropertiesGet' => [
            'application/json',
        ],
        'restPimVariationsGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restPimAttributesDelete
     *
     * Delete attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesDelete(
        string $contentType = self::contentTypes['restPimAttributesDelete'][0]
    ): object
    {
        list($response) = $this->restPimAttributesDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesDeleteWithHttpInfo
     *
     * Delete attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesDelete'][0]
    ): array
    {
        $request = $this->restPimAttributesDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesDeleteAsync
     *
     * Delete attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesDeleteAsync(
        string $contentType = self::contentTypes['restPimAttributesDelete'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesDeleteAsyncWithHttpInfo
     *
     * Delete attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesDeleteRequest(
        string $contentType = self::contentTypes['restPimAttributesDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesGet
     *
     * Search attributes
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int|null $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestItemsAttributesGet200Response
     */
    public function restPimAttributesGet(
        ?string $with = null,
        ?string $ids = null,
        ?string $backend_name = null,
        ?string $name = null,
        ?int $position = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesGet'][0]
    ): \ck/plenty-client\Model\RestItemsAttributesGet200Response
    {
        list($response) = $this->restPimAttributesGetWithHttpInfo($with, $ids, $backend_name, $name, $position, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesGetWithHttpInfo
     *
     * Search attributes
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int|null $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestItemsAttributesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesGetWithHttpInfo(
        ?string $with = null,
        ?string $ids = null,
        ?string $backend_name = null,
        ?string $name = null,
        ?int $position = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesGet'][0]
    ): array
    {
        $request = $this->restPimAttributesGetRequest($with, $ids, $backend_name, $name, $position, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestItemsAttributesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestItemsAttributesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestItemsAttributesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestItemsAttributesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestItemsAttributesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesGetAsync
     *
     * Search attributes
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int|null $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesGetAsync(
        ?string $with = null,
        ?string $ids = null,
        ?string $backend_name = null,
        ?string $name = null,
        ?int $position = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesGet'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesGetAsyncWithHttpInfo($with, $ids, $backend_name, $name, $position, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesGetAsyncWithHttpInfo
     *
     * Search attributes
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int|null $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesGetAsyncWithHttpInfo(
        $with = null,
        $ids = null,
        $backend_name = null,
        $name = null,
        $position = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestItemsAttributesGet200Response';
        $request = $this->restPimAttributesGetRequest($with, $ids, $backend_name, $name, $position, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeNames&#39; &#x3D; The attribute names of the attribute.&lt;/li&gt;&lt;li&gt; &#39;values&#39; &#x3D; The attribute values of the attribute.&lt;/li&gt;&lt;li&gt; &#39;maps&#39; &#x3D; The attribute maps of the attribute.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attributes with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attributes with the specified backend name. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  int|null $position Filter restricts the result to attributes with the specified position. Allowed comparator: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attributes which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesGetRequest(
        $with = null,
        $ids = null,
        $backend_name = null,
        $name = null,
        $position = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesGet'][0]
    ): Request
    {








        $resourcePath = '/rest/pim/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $backend_name,
            'backendName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesIdGet
     *
     * Get one attribute
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Attribute
     */
    public function restPimAttributesIdGet(
        int $id,
        string $contentType = self::contentTypes['restPimAttributesIdGet'][0]
    ): \ck/plenty-client\Model\Attribute
    {
        list($response) = $this->restPimAttributesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesIdGetWithHttpInfo
     *
     * Get one attribute
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Attribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restPimAttributesIdGet'][0]
    ): array
    {
        $request = $this->restPimAttributesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Attribute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Attribute' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Attribute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Attribute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Attribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesIdGetAsync
     *
     * Get one attribute
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restPimAttributesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesIdGetAsyncWithHttpInfo
     *
     * Get one attribute
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restPimAttributesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Attribute';
        $request = $this->restPimAttributesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restPimAttributesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restPimAttributesIdGet'
            );
        }


        $resourcePath = '/rest/pim/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesNamesDelete
     *
     * Delete attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesNamesDelete(
        string $contentType = self::contentTypes['restPimAttributesNamesDelete'][0]
    ): object
    {
        list($response) = $this->restPimAttributesNamesDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesNamesDeleteWithHttpInfo
     *
     * Delete attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesNamesDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesNamesDelete'][0]
    ): array
    {
        $request = $this->restPimAttributesNamesDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesNamesDeleteAsync
     *
     * Delete attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesNamesDeleteAsync(
        string $contentType = self::contentTypes['restPimAttributesNamesDelete'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesNamesDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesNamesDeleteAsyncWithHttpInfo
     *
     * Delete attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesNamesDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesNamesDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesNamesDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesNamesDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesNamesDeleteRequest(
        string $contentType = self::contentTypes['restPimAttributesNamesDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesNamesGet
     *
     * Search attribute names
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestPimAttributesNamesGet200Response
     */
    public function restPimAttributesNamesGet(
        ?string $with = null,
        ?string $attribute_id = null,
        ?string $lang = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restPimAttributesNamesGet'][0]
    ): \ck/plenty-client\Model\RestPimAttributesNamesGet200Response
    {
        list($response) = $this->restPimAttributesNamesGetWithHttpInfo($with, $attribute_id, $lang, $name, $contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesNamesGetWithHttpInfo
     *
     * Search attribute names
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestPimAttributesNamesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesNamesGetWithHttpInfo(
        ?string $with = null,
        ?string $attribute_id = null,
        ?string $lang = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restPimAttributesNamesGet'][0]
    ): array
    {
        $request = $this->restPimAttributesNamesGetRequest($with, $attribute_id, $lang, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestPimAttributesNamesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestPimAttributesNamesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestPimAttributesNamesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestPimAttributesNamesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestPimAttributesNamesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesNamesGetAsync
     *
     * Search attribute names
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesNamesGetAsync(
        ?string $with = null,
        ?string $attribute_id = null,
        ?string $lang = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restPimAttributesNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesNamesGetAsyncWithHttpInfo($with, $attribute_id, $lang, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesNamesGetAsyncWithHttpInfo
     *
     * Search attribute names
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesNamesGetAsyncWithHttpInfo(
        $with = null,
        $attribute_id = null,
        $lang = null,
        $name = null,
        string $contentType = self::contentTypes['restPimAttributesNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestPimAttributesNamesGet200Response';
        $request = $this->restPimAttributesNamesGetRequest($with, $attribute_id, $lang, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesNamesGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute to the attribute name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $attribute_id Filter restricts the result to attributes with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attributes with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attributes with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesNamesGetRequest(
        $with = null,
        $attribute_id = null,
        $lang = null,
        $name = null,
        string $contentType = self::contentTypes['restPimAttributesNamesGet'][0]
    ): Request
    {






        $resourcePath = '/rest/pim/attributes/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_id,
            'attributeId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesNamesPost
     *
     * Create attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesNamesPost(
        string $contentType = self::contentTypes['restPimAttributesNamesPost'][0]
    ): object
    {
        list($response) = $this->restPimAttributesNamesPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesNamesPostWithHttpInfo
     *
     * Create attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesNamesPostWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesNamesPost'][0]
    ): array
    {
        $request = $this->restPimAttributesNamesPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesNamesPostAsync
     *
     * Create attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesNamesPostAsync(
        string $contentType = self::contentTypes['restPimAttributesNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesNamesPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesNamesPostAsyncWithHttpInfo
     *
     * Create attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesNamesPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesNamesPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesNamesPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesNamesPostRequest(
        string $contentType = self::contentTypes['restPimAttributesNamesPost'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesNamesPut
     *
     * Update attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesNamesPut(
        string $contentType = self::contentTypes['restPimAttributesNamesPut'][0]
    ): object
    {
        list($response) = $this->restPimAttributesNamesPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesNamesPutWithHttpInfo
     *
     * Update attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesNamesPutWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesNamesPut'][0]
    ): array
    {
        $request = $this->restPimAttributesNamesPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesNamesPutAsync
     *
     * Update attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesNamesPutAsync(
        string $contentType = self::contentTypes['restPimAttributesNamesPut'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesNamesPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesNamesPutAsyncWithHttpInfo
     *
     * Update attribute names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesNamesPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesNamesPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesNamesPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesNamesPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesNamesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesNamesPutRequest(
        string $contentType = self::contentTypes['restPimAttributesNamesPut'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesPost
     *
     * Create attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesPost(
        string $contentType = self::contentTypes['restPimAttributesPost'][0]
    ): object
    {
        list($response) = $this->restPimAttributesPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesPostWithHttpInfo
     *
     * Create attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesPostWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesPost'][0]
    ): array
    {
        $request = $this->restPimAttributesPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesPostAsync
     *
     * Create attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesPostAsync(
        string $contentType = self::contentTypes['restPimAttributesPost'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesPostAsyncWithHttpInfo
     *
     * Create attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesPostRequest(
        string $contentType = self::contentTypes['restPimAttributesPost'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesPut
     *
     * Update attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesPut(
        string $contentType = self::contentTypes['restPimAttributesPut'][0]
    ): object
    {
        list($response) = $this->restPimAttributesPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesPutWithHttpInfo
     *
     * Update attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesPutWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesPut'][0]
    ): array
    {
        $request = $this->restPimAttributesPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesPutAsync
     *
     * Update attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesPutAsync(
        string $contentType = self::contentTypes['restPimAttributesPut'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesPutAsyncWithHttpInfo
     *
     * Update attributes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesPutRequest(
        string $contentType = self::contentTypes['restPimAttributesPut'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesDelete
     *
     * Delete attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesDelete(
        string $contentType = self::contentTypes['restPimAttributesValuesDelete'][0]
    ): object
    {
        list($response) = $this->restPimAttributesValuesDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesDeleteWithHttpInfo
     *
     * Delete attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesDelete'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesDeleteAsync
     *
     * Delete attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesDeleteAsync(
        string $contentType = self::contentTypes['restPimAttributesValuesDelete'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesDeleteAsyncWithHttpInfo
     *
     * Delete attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesDeleteRequest(
        string $contentType = self::contentTypes['restPimAttributesValuesDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesGet
     *
     * Search attribute values
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response
     */
    public function restPimAttributesValuesGet(
        ?string $with = null,
        ?string $ids = null,
        ?string $attribute_id = null,
        ?string $backend_name = null,
        ?string $name = null,
        ?string $position = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesValuesGet'][0]
    ): \ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response
    {
        list($response) = $this->restPimAttributesValuesGetWithHttpInfo($with, $ids, $attribute_id, $backend_name, $name, $position, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesGetWithHttpInfo
     *
     * Search attribute values
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesGetWithHttpInfo(
        ?string $with = null,
        ?string $ids = null,
        ?string $attribute_id = null,
        ?string $backend_name = null,
        ?string $name = null,
        ?string $position = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesValuesGet'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesGetRequest($with, $ids, $attribute_id, $backend_name, $name, $position, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesGetAsync
     *
     * Search attribute values
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesGetAsync(
        ?string $with = null,
        ?string $ids = null,
        ?string $attribute_id = null,
        ?string $backend_name = null,
        ?string $name = null,
        ?string $position = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesValuesGet'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesGetAsyncWithHttpInfo($with, $ids, $attribute_id, $backend_name, $name, $position, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesGetAsyncWithHttpInfo
     *
     * Search attribute values
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesGetAsyncWithHttpInfo(
        $with = null,
        $ids = null,
        $attribute_id = null,
        $backend_name = null,
        $name = null,
        $position = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesValuesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestItemsAttributesAttributeIdValuesGet200Response';
        $request = $this->restPimAttributesValuesGetRequest($with, $ids, $attribute_id, $backend_name, $name, $position, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;valueNames&#39; &#x3D; The names of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;attribute&#39; &#x3D; The attribute of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMaps&#39; &#x3D; The maps of the attribute value.&lt;/li&gt;&lt;li&gt; &#39;valueMarketNames&#39; &#x3D; The value market names of the attribute value.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $attribute_id Filter restricts the result to attribute values with the specified attribute ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $backend_name Filter restricts the result to attribute values with the specified backend name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute values with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $position Filter restricts the result to attribute values with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to attribute values which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesGetRequest(
        $with = null,
        $ids = null,
        $attribute_id = null,
        $backend_name = null,
        $name = null,
        $position = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restPimAttributesValuesGet'][0]
    ): Request
    {









        $resourcePath = '/rest/pim/attributes/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_id,
            'attributeId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $backend_name,
            'backendName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesIdGet
     *
     * Get one attribute value
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\AttributeValue
     */
    public function restPimAttributesValuesIdGet(
        int $id,
        string $contentType = self::contentTypes['restPimAttributesValuesIdGet'][0]
    ): \ck/plenty-client\Model\AttributeValue
    {
        list($response) = $this->restPimAttributesValuesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesIdGetWithHttpInfo
     *
     * Get one attribute value
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\AttributeValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restPimAttributesValuesIdGet'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\AttributeValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\AttributeValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\AttributeValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\AttributeValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\AttributeValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesIdGetAsync
     *
     * Get one attribute value
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restPimAttributesValuesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesIdGetAsyncWithHttpInfo
     *
     * Get one attribute value
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restPimAttributesValuesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\AttributeValue';
        $request = $this->restPimAttributesValuesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restPimAttributesValuesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restPimAttributesValuesIdGet'
            );
        }


        $resourcePath = '/rest/pim/attributes/values/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesNamesDelete
     *
     * Delete attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesNamesDelete(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesDelete'][0]
    ): object
    {
        list($response) = $this->restPimAttributesValuesNamesDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesNamesDeleteWithHttpInfo
     *
     * Delete attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesNamesDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesDelete'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesNamesDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesNamesDeleteAsync
     *
     * Delete attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesNamesDeleteAsync(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesDelete'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesNamesDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesNamesDeleteAsyncWithHttpInfo
     *
     * Delete attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesNamesDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesNamesDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesNamesDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesNamesDeleteRequest(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/values/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesNamesGet
     *
     * Search attribute value names
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response
     */
    public function restPimAttributesValuesNamesGet(
        ?string $with = null,
        ?string $value_id = null,
        ?string $lang = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restPimAttributesValuesNamesGet'][0]
    ): \ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response
    {
        list($response) = $this->restPimAttributesValuesNamesGetWithHttpInfo($with, $value_id, $lang, $name, $contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesNamesGetWithHttpInfo
     *
     * Search attribute value names
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesNamesGetWithHttpInfo(
        ?string $with = null,
        ?string $value_id = null,
        ?string $lang = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restPimAttributesValuesNamesGet'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesNamesGetRequest($with, $value_id, $lang, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesNamesGetAsync
     *
     * Search attribute value names
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesNamesGetAsync(
        ?string $with = null,
        ?string $value_id = null,
        ?string $lang = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restPimAttributesValuesNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesNamesGetAsyncWithHttpInfo($with, $value_id, $lang, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesNamesGetAsyncWithHttpInfo
     *
     * Search attribute value names
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesNamesGetAsyncWithHttpInfo(
        $with = null,
        $value_id = null,
        $lang = null,
        $name = null,
        string $contentType = self::contentTypes['restPimAttributesValuesNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestPimAttributesValuesNamesGet200Response';
        $request = $this->restPimAttributesValuesNamesGetRequest($with, $value_id, $lang, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesNamesGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;attributeValue&#39; &#x3D; The attribute value to the attribute value name.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $value_id Filter restricts the result to attribute value names with the specified value ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39; (optional)
     * @param  string|null $lang Filter restricts the result to attribute value names with the specified language. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;in&#39;. (optional)
     * @param  string|null $name Filter restricts the result to attribute value names with the specified name. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesNamesGetRequest(
        $with = null,
        $value_id = null,
        $lang = null,
        $name = null,
        string $contentType = self::contentTypes['restPimAttributesValuesNamesGet'][0]
    ): Request
    {






        $resourcePath = '/rest/pim/attributes/values/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value_id,
            'valueId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesNamesPost
     *
     * Create attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesNamesPost(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPost'][0]
    ): object
    {
        list($response) = $this->restPimAttributesValuesNamesPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesNamesPostWithHttpInfo
     *
     * Create attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesNamesPostWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPost'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesNamesPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesNamesPostAsync
     *
     * Create attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesNamesPostAsync(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesNamesPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesNamesPostAsyncWithHttpInfo
     *
     * Create attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesNamesPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesNamesPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesNamesPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesNamesPostRequest(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPost'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/values/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesNamesPut
     *
     * Update attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesNamesPut(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPut'][0]
    ): object
    {
        list($response) = $this->restPimAttributesValuesNamesPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesNamesPutWithHttpInfo
     *
     * Update attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesNamesPutWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPut'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesNamesPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesNamesPutAsync
     *
     * Update attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesNamesPutAsync(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPut'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesNamesPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesNamesPutAsyncWithHttpInfo
     *
     * Update attribute value names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesNamesPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesNamesPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesNamesPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesNamesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesNamesPutRequest(
        string $contentType = self::contentTypes['restPimAttributesValuesNamesPut'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/values/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesPost
     *
     * Create attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesPost(
        string $contentType = self::contentTypes['restPimAttributesValuesPost'][0]
    ): object
    {
        list($response) = $this->restPimAttributesValuesPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesPostWithHttpInfo
     *
     * Create attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesPostWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesPost'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesPostAsync
     *
     * Create attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesPostAsync(
        string $contentType = self::contentTypes['restPimAttributesValuesPost'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesPostAsyncWithHttpInfo
     *
     * Create attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesPostRequest(
        string $contentType = self::contentTypes['restPimAttributesValuesPost'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimAttributesValuesPut
     *
     * Update attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPimAttributesValuesPut(
        string $contentType = self::contentTypes['restPimAttributesValuesPut'][0]
    ): object
    {
        list($response) = $this->restPimAttributesValuesPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPimAttributesValuesPutWithHttpInfo
     *
     * Update attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimAttributesValuesPutWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesPut'][0]
    ): array
    {
        $request = $this->restPimAttributesValuesPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimAttributesValuesPutAsync
     *
     * Update attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesPutAsync(
        string $contentType = self::contentTypes['restPimAttributesValuesPut'][0]
    ): PromiseInterface
    {
        return $this->restPimAttributesValuesPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimAttributesValuesPutAsyncWithHttpInfo
     *
     * Update attribute values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimAttributesValuesPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPimAttributesValuesPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPimAttributesValuesPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimAttributesValuesPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimAttributesValuesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimAttributesValuesPutRequest(
        string $contentType = self::contentTypes['restPimAttributesValuesPut'][0]
    ): Request
    {


        $resourcePath = '/rest/pim/attributes/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesBranchesGet
     *
     * Search category branches
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesBranchesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response
     */
    public function restPimCategoriesBranchesGet(
        ?string $with = null,
        string $contentType = self::contentTypes['restPimCategoriesBranchesGet'][0]
    ): \ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response
    {
        list($response) = $this->restPimCategoriesBranchesGetWithHttpInfo($with, $contentType);
        return $response;
    }

    /**
     * Operation restPimCategoriesBranchesGetWithHttpInfo
     *
     * Search category branches
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesBranchesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesBranchesGetWithHttpInfo(
        ?string $with = null,
        string $contentType = self::contentTypes['restPimCategoriesBranchesGet'][0]
    ): array
    {
        $request = $this->restPimCategoriesBranchesGetRequest($with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesBranchesGetAsync
     *
     * Search category branches
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesBranchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesBranchesGetAsync(
        ?string $with = null,
        string $contentType = self::contentTypes['restPimCategoriesBranchesGet'][0]
    ): PromiseInterface
    {
        return $this->restPimCategoriesBranchesGetAsyncWithHttpInfo($with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesBranchesGetAsyncWithHttpInfo
     *
     * Search category branches
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesBranchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesBranchesGetAsyncWithHttpInfo(
        $with = null,
        string $contentType = self::contentTypes['restPimCategoriesBranchesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestPimCategoriesBranchesGet200Response';
        $request = $this->restPimCategoriesBranchesGetRequest($with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesBranchesGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category branch.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesBranchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimCategoriesBranchesGetRequest(
        $with = null,
        string $contentType = self::contentTypes['restPimCategoriesBranchesGet'][0]
    ): Request
    {



        $resourcePath = '/rest/pim/categories/branches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesClientsGet
     *
     * Search category clients
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesClientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestPimCategoriesClientsGet200Response
     */
    public function restPimCategoriesClientsGet(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        string $contentType = self::contentTypes['restPimCategoriesClientsGet'][0]
    ): \ck/plenty-client\Model\RestPimCategoriesClientsGet200Response
    {
        list($response) = $this->restPimCategoriesClientsGetWithHttpInfo($with, $category_id, $plenty_id, $contentType);
        return $response;
    }

    /**
     * Operation restPimCategoriesClientsGetWithHttpInfo
     *
     * Search category clients
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesClientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestPimCategoriesClientsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesClientsGetWithHttpInfo(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        string $contentType = self::contentTypes['restPimCategoriesClientsGet'][0]
    ): array
    {
        $request = $this->restPimCategoriesClientsGetRequest($with, $category_id, $plenty_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestPimCategoriesClientsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestPimCategoriesClientsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestPimCategoriesClientsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestPimCategoriesClientsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestPimCategoriesClientsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesClientsGetAsync
     *
     * Search category clients
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesClientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesClientsGetAsync(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        string $contentType = self::contentTypes['restPimCategoriesClientsGet'][0]
    ): PromiseInterface
    {
        return $this->restPimCategoriesClientsGetAsyncWithHttpInfo($with, $category_id, $plenty_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesClientsGetAsyncWithHttpInfo
     *
     * Search category clients
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesClientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesClientsGetAsyncWithHttpInfo(
        $with = null,
        $category_id = null,
        $plenty_id = null,
        string $contentType = self::contentTypes['restPimCategoriesClientsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestPimCategoriesClientsGet200Response';
        $request = $this->restPimCategoriesClientsGetRequest($with, $category_id, $plenty_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesClientsGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category client.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category clients with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category clients with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesClientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimCategoriesClientsGetRequest(
        $with = null,
        $category_id = null,
        $plenty_id = null,
        string $contentType = self::contentTypes['restPimCategoriesClientsGet'][0]
    ): Request
    {





        $resourcePath = '/rest/pim/categories/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesDetailsGet
     *
     * Search category details
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string|null $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesDetailsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response
     */
    public function restPimCategoriesDetailsGet(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        ?string $lang = null,
        ?string $name = null,
        ?string $position = null,
        string $contentType = self::contentTypes['restPimCategoriesDetailsGet'][0]
    ): \ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response
    {
        list($response) = $this->restPimCategoriesDetailsGetWithHttpInfo($with, $category_id, $plenty_id, $lang, $name, $position, $contentType);
        return $response;
    }

    /**
     * Operation restPimCategoriesDetailsGetWithHttpInfo
     *
     * Search category details
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string|null $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesDetailsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesDetailsGetWithHttpInfo(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        ?string $lang = null,
        ?string $name = null,
        ?string $position = null,
        string $contentType = self::contentTypes['restPimCategoriesDetailsGet'][0]
    ): array
    {
        $request = $this->restPimCategoriesDetailsGetRequest($with, $category_id, $plenty_id, $lang, $name, $position, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesDetailsGetAsync
     *
     * Search category details
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string|null $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesDetailsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesDetailsGetAsync(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        ?string $lang = null,
        ?string $name = null,
        ?string $position = null,
        string $contentType = self::contentTypes['restPimCategoriesDetailsGet'][0]
    ): PromiseInterface
    {
        return $this->restPimCategoriesDetailsGetAsyncWithHttpInfo($with, $category_id, $plenty_id, $lang, $name, $position, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesDetailsGetAsyncWithHttpInfo
     *
     * Search category details
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string|null $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesDetailsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesDetailsGetAsyncWithHttpInfo(
        $with = null,
        $category_id = null,
        $plenty_id = null,
        $lang = null,
        $name = null,
        $position = null,
        string $contentType = self::contentTypes['restPimCategoriesDetailsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestPimCategoriesDetailsGet200Response';
        $request = $this->restPimCategoriesDetailsGetRequest($with, $category_id, $plenty_id, $lang, $name, $position, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesDetailsGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the category detail.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category details with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $name Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39; and &#39;like&#39;. (optional)
     * @param  string|null $position Filter restricts the result to category details with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesDetailsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimCategoriesDetailsGetRequest(
        $with = null,
        $category_id = null,
        $plenty_id = null,
        $lang = null,
        $name = null,
        $position = null,
        string $contentType = self::contentTypes['restPimCategoriesDetailsGet'][0]
    ): Request
    {








        $resourcePath = '/rest/pim/categories/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesGet
     *
     * Search categories
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int|null $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int|null $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool|null $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string|null $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestCategoriesGet200Response
     */
    public function restPimCategoriesGet(
        ?string $with = null,
        ?string $ids = null,
        ?string $type = null,
        ?int $level = null,
        ?string $name = null,
        ?string $lang = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?bool $linklist = null,
        ?string $tag_id = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimCategoriesGet'][0]
    ): \ck/plenty-client\Model\RestCategoriesGet200Response
    {
        list($response) = $this->restPimCategoriesGetWithHttpInfo($with, $ids, $type, $level, $name, $lang, $parent_id, $plenty_id, $linklist, $tag_id, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restPimCategoriesGetWithHttpInfo
     *
     * Search categories
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int|null $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int|null $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool|null $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string|null $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestCategoriesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesGetWithHttpInfo(
        ?string $with = null,
        ?string $ids = null,
        ?string $type = null,
        ?int $level = null,
        ?string $name = null,
        ?string $lang = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?bool $linklist = null,
        ?string $tag_id = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimCategoriesGet'][0]
    ): array
    {
        $request = $this->restPimCategoriesGetRequest($with, $ids, $type, $level, $name, $lang, $parent_id, $plenty_id, $linklist, $tag_id, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestCategoriesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestCategoriesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestCategoriesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestCategoriesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestCategoriesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesGetAsync
     *
     * Search categories
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int|null $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int|null $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool|null $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string|null $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesGetAsync(
        ?string $with = null,
        ?string $ids = null,
        ?string $type = null,
        ?int $level = null,
        ?string $name = null,
        ?string $lang = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?bool $linklist = null,
        ?string $tag_id = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restPimCategoriesGet'][0]
    ): PromiseInterface
    {
        return $this->restPimCategoriesGetAsyncWithHttpInfo($with, $ids, $type, $level, $name, $lang, $parent_id, $plenty_id, $linklist, $tag_id, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesGetAsyncWithHttpInfo
     *
     * Search categories
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int|null $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int|null $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool|null $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string|null $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesGetAsyncWithHttpInfo(
        $with = null,
        $ids = null,
        $type = null,
        $level = null,
        $name = null,
        $lang = null,
        $parent_id = null,
        $plenty_id = null,
        $linklist = null,
        $tag_id = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restPimCategoriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestCategoriesGet200Response';
        $request = $this->restPimCategoriesGetRequest($with, $ids, $type, $level, $name, $lang, $parent_id, $plenty_id, $linklist, $tag_id, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;details&#39; &#x3D; The names of the category.&lt;/li&gt;&lt;li&gt; &#39;clients&#39; &#x3D; The clients of the category.&lt;/li&gt;&lt;li&gt; &#39;branch&#39; &#x3D; The branch of the category.&lt;/li&gt;&lt;li&gt; &#39;tagRelationship&#39; &#x3D; The tags linked with the category and their data.&lt;/li&gt;&lt;li&gt; &#39;elmarCategories&#39; &#x3D; The elmar categories of the category.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $ids Filter restricts the result to categories with the specified IDs. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $type Filter restricts the result to categories with the specified type. Allowed comparators: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  int|null $level Filter restricts the result to categories with the specified level. Allowed comparators: &#39;eq&#39;, &#39;not&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string|null $name Filter restricts the result to categories with a category detail in the specified name. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $lang Filter restricts the result to categories with a category detail in the specified lang. Allowed comparators: &#39;eq&#39; and &#39;not&#39;. (optional)
     * @param  int|null $parent_id Filter restricts the result to categories with the specified parent ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to categories with the specified plenty ID. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  bool|null $linklist Filter restricts the result to categories with the specified linklist value. Allowed comparator: &#39;eq&#39;. (optional)
     * @param  string|null $tag_id Filter restricts the result to categories with the specified tag id. Allowed comparator: &#39;eq&#39;, &#39;in&#39; and &#39;not&#39;. (optional)
     * @param  string|null $updated_at Filter restricts the result to categories which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. Allowed comparator: &#39;eq&#39;&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimCategoriesGetRequest(
        $with = null,
        $ids = null,
        $type = null,
        $level = null,
        $name = null,
        $lang = null,
        $parent_id = null,
        $plenty_id = null,
        $linklist = null,
        $tag_id = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restPimCategoriesGet'][0]
    ): Request
    {













        $resourcePath = '/rest/pim/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linklist,
            'linklist', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag_id,
            'tagId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesIdGet
     *
     * Get one category
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Category
     */
    public function restPimCategoriesIdGet(
        int $id,
        string $contentType = self::contentTypes['restPimCategoriesIdGet'][0]
    ): \ck/plenty-client\Model\Category
    {
        list($response) = $this->restPimCategoriesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restPimCategoriesIdGetWithHttpInfo
     *
     * Get one category
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restPimCategoriesIdGet'][0]
    ): array
    {
        $request = $this->restPimCategoriesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Category' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Category' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Category', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Category';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesIdGetAsync
     *
     * Get one category
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restPimCategoriesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPimCategoriesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesIdGetAsyncWithHttpInfo
     *
     * Get one category
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restPimCategoriesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Category';
        $request = $this->restPimCategoriesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimCategoriesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restPimCategoriesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restPimCategoriesIdGet'
            );
        }


        $resourcePath = '/rest/pim/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimCategoriesPropertiesGet
     *
     * Search category properties
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response
     */
    public function restPimCategoriesPropertiesGet(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        ?string $value = null,
        string $contentType = self::contentTypes['restPimCategoriesPropertiesGet'][0]
    ): \ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response
    {
        list($response) = $this->restPimCategoriesPropertiesGetWithHttpInfo($with, $category_id, $plenty_id, $value, $contentType);
        return $response;
    }

    /**
     * Operation restPimCategoriesPropertiesGetWithHttpInfo
     *
     * Search category properties
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimCategoriesPropertiesGetWithHttpInfo(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        ?string $value = null,
        string $contentType = self::contentTypes['restPimCategoriesPropertiesGet'][0]
    ): array
    {
        $request = $this->restPimCategoriesPropertiesGetRequest($with, $category_id, $plenty_id, $value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimCategoriesPropertiesGetAsync
     *
     * Search category properties
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesPropertiesGetAsync(
        ?string $with = null,
        ?string $category_id = null,
        ?int $plenty_id = null,
        ?string $value = null,
        string $contentType = self::contentTypes['restPimCategoriesPropertiesGet'][0]
    ): PromiseInterface
    {
        return $this->restPimCategoriesPropertiesGetAsyncWithHttpInfo($with, $category_id, $plenty_id, $value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimCategoriesPropertiesGetAsyncWithHttpInfo
     *
     * Search category properties
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimCategoriesPropertiesGetAsyncWithHttpInfo(
        $with = null,
        $category_id = null,
        $plenty_id = null,
        $value = null,
        string $contentType = self::contentTypes['restPimCategoriesPropertiesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestPimCategoriesPropertiesGet200Response';
        $request = $this->restPimCategoriesPropertiesGetRequest($with, $category_id, $plenty_id, $value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimCategoriesPropertiesGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt; &#39;category&#39; &#x3D; The category of the property.&lt;/li&gt;&lt;/ub&gt; (optional)
     * @param  string|null $category_id Filter restricts the result to category properties with the specified category ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;, &#39;in&#39;, &#39;between&#39;, &#39;gte&#39;, &#39;lte&#39;, &#39;gt&#39; and &#39;lt&#39;. (optional)
     * @param  int|null $plenty_id Filter restricts the result to category properties with the specified plenty ID. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string|null $value Filter restricts the result to category properties with the specified value. More than one parameter should be separated by commas. Allowed comparators: &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimCategoriesPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimCategoriesPropertiesGetRequest(
        $with = null,
        $category_id = null,
        $plenty_id = null,
        $value = null,
        string $contentType = self::contentTypes['restPimCategoriesPropertiesGet'][0]
    ): Request
    {






        $resourcePath = '/rest/pim/categories/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value,
            'value', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPimVariationsGet
     *
     * Lists variations
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string|null $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool|null $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string|null $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool|null $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int|null $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string|null $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string|null $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int|null $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string|null $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string|null $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string|null $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int|null $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string|null $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float|null $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int|null $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int|null $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string|null $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float|null $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string|null $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string|null $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string|null $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string|null $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string|null $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string|null $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string|null $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int|null $page The requested page of results. Default value is 1. (optional)
     * @param  int|null $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimVariationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestItemsVariationsGet200Response
     */
    public function restPimVariationsGet(
        ?string $with = null,
        ?string $sort_by = null,
        ?string $group_by = null,
        ?string $ids = null,
        ?int $item_id = null,
        ?string $item_ids = null,
        ?bool $is_active = null,
        ?bool $is_main = null,
        ?bool $is_salable = null,
        ?int $supplier_id = null,
        ?string $availability_ids = null,
        ?bool $has_children = null,
        ?bool $has_active_children = null,
        ?int $attribute_id = null,
        ?string $any_attribute_id = null,
        ?string $all_attribute_ids = null,
        ?int $attribute_value_id = null,
        ?string $any_attribute_value_id = null,
        ?string $all_attribute_value_ids = null,
        ?string $barcode_code = null,
        ?int $barcode_id = null,
        ?string $bundle_type = null,
        ?int $category_id = null,
        ?string $any_category_id = null,
        ?string $all_category_ids = null,
        ?string $any_characteristic_id = null,
        ?string $all_characteristic_ids = null,
        ?int $client_id = null,
        ?string $any_client_id = null,
        ?string $all_client_ids = null,
        ?string $automatic_client_visibilities = null,
        ?float $image_has_market_id = null,
        ?int $flag1 = null,
        ?int $flag2 = null,
        ?int $manufacturer_id = null,
        ?string $any_manufacturer_id = null,
        ?string $item_type = null,
        ?float $market_id = null,
        ?string $any_market_id = null,
        ?string $all_market_ids = null,
        ?string $price_between = null,
        ?string $price_between_by_id = null,
        ?string $any_sales_price_id = null,
        ?int $property_selection_id = null,
        ?string $any_property_selection_id = null,
        ?string $all_property_selection_ids = null,
        ?string $has_name_in_language = null,
        ?string $created_at = null,
        ?string $updated_at = null,
        ?string $item_created_at = null,
        ?string $item_updated_at = null,
        ?string $availability_updated_at = null,
        ?string $stock_updated_at = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restPimVariationsGet'][0]
    ): \ck/plenty-client\Model\RestItemsVariationsGet200Response
    {
        list($response) = $this->restPimVariationsGetWithHttpInfo($with, $sort_by, $group_by, $ids, $item_id, $item_ids, $is_active, $is_main, $is_salable, $supplier_id, $availability_ids, $has_children, $has_active_children, $attribute_id, $any_attribute_id, $all_attribute_ids, $attribute_value_id, $any_attribute_value_id, $all_attribute_value_ids, $barcode_code, $barcode_id, $bundle_type, $category_id, $any_category_id, $all_category_ids, $any_characteristic_id, $all_characteristic_ids, $client_id, $any_client_id, $all_client_ids, $automatic_client_visibilities, $image_has_market_id, $flag1, $flag2, $manufacturer_id, $any_manufacturer_id, $item_type, $market_id, $any_market_id, $all_market_ids, $price_between, $price_between_by_id, $any_sales_price_id, $property_selection_id, $any_property_selection_id, $all_property_selection_ids, $has_name_in_language, $created_at, $updated_at, $item_created_at, $item_updated_at, $availability_updated_at, $stock_updated_at, $page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restPimVariationsGetWithHttpInfo
     *
     * Lists variations
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string|null $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool|null $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string|null $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool|null $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int|null $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string|null $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string|null $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int|null $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string|null $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string|null $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string|null $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int|null $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string|null $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float|null $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int|null $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int|null $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string|null $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float|null $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string|null $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string|null $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string|null $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string|null $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string|null $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string|null $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string|null $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int|null $page The requested page of results. Default value is 1. (optional)
     * @param  int|null $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimVariationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestItemsVariationsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPimVariationsGetWithHttpInfo(
        ?string $with = null,
        ?string $sort_by = null,
        ?string $group_by = null,
        ?string $ids = null,
        ?int $item_id = null,
        ?string $item_ids = null,
        ?bool $is_active = null,
        ?bool $is_main = null,
        ?bool $is_salable = null,
        ?int $supplier_id = null,
        ?string $availability_ids = null,
        ?bool $has_children = null,
        ?bool $has_active_children = null,
        ?int $attribute_id = null,
        ?string $any_attribute_id = null,
        ?string $all_attribute_ids = null,
        ?int $attribute_value_id = null,
        ?string $any_attribute_value_id = null,
        ?string $all_attribute_value_ids = null,
        ?string $barcode_code = null,
        ?int $barcode_id = null,
        ?string $bundle_type = null,
        ?int $category_id = null,
        ?string $any_category_id = null,
        ?string $all_category_ids = null,
        ?string $any_characteristic_id = null,
        ?string $all_characteristic_ids = null,
        ?int $client_id = null,
        ?string $any_client_id = null,
        ?string $all_client_ids = null,
        ?string $automatic_client_visibilities = null,
        ?float $image_has_market_id = null,
        ?int $flag1 = null,
        ?int $flag2 = null,
        ?int $manufacturer_id = null,
        ?string $any_manufacturer_id = null,
        ?string $item_type = null,
        ?float $market_id = null,
        ?string $any_market_id = null,
        ?string $all_market_ids = null,
        ?string $price_between = null,
        ?string $price_between_by_id = null,
        ?string $any_sales_price_id = null,
        ?int $property_selection_id = null,
        ?string $any_property_selection_id = null,
        ?string $all_property_selection_ids = null,
        ?string $has_name_in_language = null,
        ?string $created_at = null,
        ?string $updated_at = null,
        ?string $item_created_at = null,
        ?string $item_updated_at = null,
        ?string $availability_updated_at = null,
        ?string $stock_updated_at = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restPimVariationsGet'][0]
    ): array
    {
        $request = $this->restPimVariationsGetRequest($with, $sort_by, $group_by, $ids, $item_id, $item_ids, $is_active, $is_main, $is_salable, $supplier_id, $availability_ids, $has_children, $has_active_children, $attribute_id, $any_attribute_id, $all_attribute_ids, $attribute_value_id, $any_attribute_value_id, $all_attribute_value_ids, $barcode_code, $barcode_id, $bundle_type, $category_id, $any_category_id, $all_category_ids, $any_characteristic_id, $all_characteristic_ids, $client_id, $any_client_id, $all_client_ids, $automatic_client_visibilities, $image_has_market_id, $flag1, $flag2, $manufacturer_id, $any_manufacturer_id, $item_type, $market_id, $any_market_id, $all_market_ids, $price_between, $price_between_by_id, $any_sales_price_id, $property_selection_id, $any_property_selection_id, $all_property_selection_ids, $has_name_in_language, $created_at, $updated_at, $item_created_at, $item_updated_at, $availability_updated_at, $stock_updated_at, $page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestItemsVariationsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestItemsVariationsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestItemsVariationsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestItemsVariationsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestItemsVariationsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPimVariationsGetAsync
     *
     * Lists variations
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string|null $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool|null $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string|null $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool|null $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int|null $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string|null $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string|null $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int|null $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string|null $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string|null $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string|null $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int|null $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string|null $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float|null $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int|null $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int|null $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string|null $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float|null $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string|null $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string|null $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string|null $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string|null $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string|null $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string|null $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string|null $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int|null $page The requested page of results. Default value is 1. (optional)
     * @param  int|null $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimVariationsGetAsync(
        ?string $with = null,
        ?string $sort_by = null,
        ?string $group_by = null,
        ?string $ids = null,
        ?int $item_id = null,
        ?string $item_ids = null,
        ?bool $is_active = null,
        ?bool $is_main = null,
        ?bool $is_salable = null,
        ?int $supplier_id = null,
        ?string $availability_ids = null,
        ?bool $has_children = null,
        ?bool $has_active_children = null,
        ?int $attribute_id = null,
        ?string $any_attribute_id = null,
        ?string $all_attribute_ids = null,
        ?int $attribute_value_id = null,
        ?string $any_attribute_value_id = null,
        ?string $all_attribute_value_ids = null,
        ?string $barcode_code = null,
        ?int $barcode_id = null,
        ?string $bundle_type = null,
        ?int $category_id = null,
        ?string $any_category_id = null,
        ?string $all_category_ids = null,
        ?string $any_characteristic_id = null,
        ?string $all_characteristic_ids = null,
        ?int $client_id = null,
        ?string $any_client_id = null,
        ?string $all_client_ids = null,
        ?string $automatic_client_visibilities = null,
        ?float $image_has_market_id = null,
        ?int $flag1 = null,
        ?int $flag2 = null,
        ?int $manufacturer_id = null,
        ?string $any_manufacturer_id = null,
        ?string $item_type = null,
        ?float $market_id = null,
        ?string $any_market_id = null,
        ?string $all_market_ids = null,
        ?string $price_between = null,
        ?string $price_between_by_id = null,
        ?string $any_sales_price_id = null,
        ?int $property_selection_id = null,
        ?string $any_property_selection_id = null,
        ?string $all_property_selection_ids = null,
        ?string $has_name_in_language = null,
        ?string $created_at = null,
        ?string $updated_at = null,
        ?string $item_created_at = null,
        ?string $item_updated_at = null,
        ?string $availability_updated_at = null,
        ?string $stock_updated_at = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restPimVariationsGet'][0]
    ): PromiseInterface
    {
        return $this->restPimVariationsGetAsyncWithHttpInfo($with, $sort_by, $group_by, $ids, $item_id, $item_ids, $is_active, $is_main, $is_salable, $supplier_id, $availability_ids, $has_children, $has_active_children, $attribute_id, $any_attribute_id, $all_attribute_ids, $attribute_value_id, $any_attribute_value_id, $all_attribute_value_ids, $barcode_code, $barcode_id, $bundle_type, $category_id, $any_category_id, $all_category_ids, $any_characteristic_id, $all_characteristic_ids, $client_id, $any_client_id, $all_client_ids, $automatic_client_visibilities, $image_has_market_id, $flag1, $flag2, $manufacturer_id, $any_manufacturer_id, $item_type, $market_id, $any_market_id, $all_market_ids, $price_between, $price_between_by_id, $any_sales_price_id, $property_selection_id, $any_property_selection_id, $all_property_selection_ids, $has_name_in_language, $created_at, $updated_at, $item_created_at, $item_updated_at, $availability_updated_at, $stock_updated_at, $page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPimVariationsGetAsyncWithHttpInfo
     *
     * Lists variations
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string|null $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool|null $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string|null $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool|null $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int|null $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string|null $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string|null $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int|null $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string|null $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string|null $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string|null $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int|null $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string|null $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float|null $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int|null $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int|null $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string|null $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float|null $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string|null $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string|null $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string|null $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string|null $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string|null $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string|null $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string|null $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int|null $page The requested page of results. Default value is 1. (optional)
     * @param  int|null $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPimVariationsGetAsyncWithHttpInfo(
        $with = null,
        $sort_by = null,
        $group_by = null,
        $ids = null,
        $item_id = null,
        $item_ids = null,
        $is_active = null,
        $is_main = null,
        $is_salable = null,
        $supplier_id = null,
        $availability_ids = null,
        $has_children = null,
        $has_active_children = null,
        $attribute_id = null,
        $any_attribute_id = null,
        $all_attribute_ids = null,
        $attribute_value_id = null,
        $any_attribute_value_id = null,
        $all_attribute_value_ids = null,
        $barcode_code = null,
        $barcode_id = null,
        $bundle_type = null,
        $category_id = null,
        $any_category_id = null,
        $all_category_ids = null,
        $any_characteristic_id = null,
        $all_characteristic_ids = null,
        $client_id = null,
        $any_client_id = null,
        $all_client_ids = null,
        $automatic_client_visibilities = null,
        $image_has_market_id = null,
        $flag1 = null,
        $flag2 = null,
        $manufacturer_id = null,
        $any_manufacturer_id = null,
        $item_type = null,
        $market_id = null,
        $any_market_id = null,
        $all_market_ids = null,
        $price_between = null,
        $price_between_by_id = null,
        $any_sales_price_id = null,
        $property_selection_id = null,
        $any_property_selection_id = null,
        $all_property_selection_ids = null,
        $has_name_in_language = null,
        $created_at = null,
        $updated_at = null,
        $item_created_at = null,
        $item_updated_at = null,
        $availability_updated_at = null,
        $stock_updated_at = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restPimVariationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestItemsVariationsGet200Response';
        $request = $this->restPimVariationsGetRequest($with, $sort_by, $group_by, $ids, $item_id, $item_ids, $is_active, $is_main, $is_salable, $supplier_id, $availability_ids, $has_children, $has_active_children, $attribute_id, $any_attribute_id, $all_attribute_ids, $attribute_value_id, $any_attribute_value_id, $all_attribute_value_ids, $barcode_code, $barcode_id, $bundle_type, $category_id, $any_category_id, $all_category_ids, $any_characteristic_id, $all_characteristic_ids, $client_id, $any_client_id, $all_client_ids, $automatic_client_visibilities, $image_has_market_id, $flag1, $flag2, $manufacturer_id, $any_manufacturer_id, $item_type, $market_id, $any_market_id, $all_market_ids, $price_between, $price_between_by_id, $any_sales_price_id, $property_selection_id, $any_property_selection_id, $all_property_selection_ids, $has_name_in_language, $created_at, $updated_at, $item_created_at, $item_updated_at, $availability_updated_at, $stock_updated_at, $page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPimVariationsGet'
     *
     * @param  string|null $with Includes the specified information in the results. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;additionalSkus&#39; &#x3D; The additional skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues&#39; &#x3D; The attribute values of the variation.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attribute&#39;/b&gt; &#x3D; Includes attributeValues. The attribute data to the related attribute ID.&lt;/li&gt;&lt;li&gt;&#39;attributeValues.attributeValue&#39; &#x3D; Includes attributeValues. The attribute value data to the related attribute value ID.&lt;/li&gt;&lt;li&gt;&#39;barcodes&#39; &#x3D; The barcodes of the variation.&lt;/li&gt;&lt;li&gt;&#39;barcodes.barcode&#39; &#x3D; Includes barcodes. The barcode data to the related barcode ID.&lt;/li&gt;&lt;li&gt;&#39;base&#39; &#x3D; The variation base.&lt;/li&gt;&lt;li&gt;&#39;base.item&#39; &#x3D; Includes base. The item data of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.itemSerialNumber&#39; &#x3D; Includes base. The item serial numbers of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.feedback&#39; &#x3D; Includes base. The feedback of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.characteristics&#39; &#x3D; Includes base. The characteristics of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.crossSelling&#39; &#x3D; Includes base. The cross selling items of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.texts&#39; &#x3D; Includes base. The texts of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.availability&#39; &#x3D; Includes base. The availability data related to the variation&#39;s availability ID.&lt;/li&gt;&lt;li&gt;&#39;base.images&#39; &#x3D; Includes base. The images linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.shippingProfiles&#39; &#x3D; Includes base. The shipping profiles linked to the item.&lt;/li&gt;&lt;li&gt;&#39;base.stock&#39; &#x3D; Includes base. The stock of the variation.&lt;/li&gt;&lt;li&gt;&#39;base.stockStorageLocations&#39; &#x3D; Includes base. The stock storage locations of the variation.&lt;/li&gt;&lt;li&gt;&#39;bundleComponents&#39; &#x3D; The bundle components of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories&#39; &#x3D; The categories of the variation.&lt;/li&gt;&lt;li&gt;&#39;categories.category&#39; &#x3D; Includes categories. The related category data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;categories.categoryBranch&#39; &#x3D; Includes categories. The related category branch data for each category ID.&lt;/li&gt;&lt;li&gt;&#39;clients&#39; &#x3D; The clients of the variation.&lt;/li&gt;&lt;li&gt;&#39;defaultCategories&#39; &#x3D; The default categories of the variation&lt;/li&gt;&lt;li&gt;&#39;defaultCategories.category&#39; &#x3D; Includes defaultCategories. The category data to the related category ID.&lt;/li&gt;&lt;li&gt;&#39;images&#39; &#x3D; The images of the variation&lt;/li&gt;&lt;li&gt;&#39;images.image&#39; &#x3D; Includes images. The image data to the related image ID.&lt;/li&gt;&lt;li&gt;&#39;markets&#39; &#x3D; The markets of the variation.&lt;/li&gt;&lt;li&gt;&#39;marketIdentNumbers&#39; &#x3D; The market ident numbers of the variation&lt;/li&gt;&lt;li&gt;&#39;salesPrices&#39; &#x3D; The sales prices of the variation.&lt;/li&gt;&lt;li&gt;&#39;salesPrices.salesPrice&#39; &#x3D; Includes salesPrices. The sales price data to the related sales price ID.&lt;/li&gt;&lt;li&gt;&#39;skus&#39; &#x3D; The skus of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier&#39; &#x3D; The supplier of the variation.&lt;/li&gt;&lt;li&gt;&#39;supplier.supplier&#39; &#x3D; Includes supplier. The contact data to the related supplier ID.&lt;/li&gt;&lt;li&gt;&#39;timestamps&#39; &#x3D; The timetamps of the variation.&lt;/li&gt;&lt;li&gt;&#39;warehouses&#39; &#x3D; The warehouses of the variation&lt;/li&gt;&lt;li&gt;&#39;warehouses.warehouse&#39; &#x3D; Includes warehouses. The warehouse data to the related warehouse ID.&lt;/li&gt;&lt;li&gt;&#39;unit&#39; &#x3D; The unit of the variation&lt;/li&gt;&lt;li&gt;&#39;unit.unit&#39; &#x3D; Includes unit. The unit data of the related unit ID.&lt;/li&gt;&lt;li&gt;&#39;tags&#39; &#x3D; The tags of the variation.&lt;/li&gt;&lt;li&gt;&#39;tags.tag&#39; &#x3D; Includes tags. The tag data to the related tag ID.&lt;/li&gt;&lt;li&gt;&#39;properties&#39; &#x3D; The properties of the variation.&lt;/li&gt;&lt;li&gt;&#39;properties.property&#39; &#x3D; Includes properties. The property data to the related property ID.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $sort_by Sorts the results. Append &#39;_asc&#39; or &#39;_desc&#39; to specify the sorting order. &#39;_desc&#39; is the default value if no other is specified. More than one parameter should be separated by commas. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;id&#39;&lt;/li&gt;&lt;li&gt;&#39;itemId&#39;&lt;/li&gt;&lt;li&gt;&#39;isMain&#39;&lt;/li&gt;&lt;li&gt;&#39;position&#39;&lt;/li&gt;&lt;li&gt;&#39;availabilityId&#39;&lt;/li&gt;&lt;li&gt;&#39;createdAt&#39;&lt;/li&gt;&lt;li&gt;&#39;updatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;itemUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;relatedUpdatedAt&#39;&lt;/li&gt;&lt;li&gt;&#39;variationName&#39;&lt;/li&gt;&lt;li&gt;&#39;number&#39;&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $group_by Groups the result. The following parameters are available:&lt;ul&gt;&lt;li&gt;&#39;itemId&#39; &#x3D; Groups the result by the item ID.&lt;/li&gt;&lt;li&gt;&#39;itemAttributeValue&#39; &#x3D; Groups the result by the attribute with the flag &#39;isGroupable&#39;.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $ids Filter restricts the list of results to variations with the specified IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. (optional)
     * @param  string|null $item_ids Filter restricts the list of results to variations with the specified item IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations which are active/inactive. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations which are main/not main. (optional)
     * @param  bool|null $is_salable Filter restricts the list of results to variations which are salable. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations which have the given supplier ID. (optional)
     * @param  string|null $availability_ids Filter restricts the list of results to variations with the specified availability IDs. More than one parameter should be separated by commas. (optional)
     * @param  bool|null $has_children Filter restricts the list of results to variations which have children. (optional)
     * @param  bool|null $has_active_children Filter restricts the list of results to variations which have active children. (optional)
     * @param  int|null $attribute_id Filter restricts the list of results to variations which have the specified attribute ID. (optional)
     * @param  string|null $any_attribute_id Filter restricts the list of results to variations which have any of the specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_ids Filter restricts the list of results to variations which have all specified attribute IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $attribute_value_id Filter restricts the list of results to variations which have the specified attribute value ID. (optional)
     * @param  string|null $any_attribute_value_id Filter restricts the list of results to variations which have the any of the specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_attribute_value_ids Filter restricts the list of results to variations which have all specified attribute value IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $barcode_code Filter restricts the list of results to variations which have a barcode with the specified code. (optional)
     * @param  int|null $barcode_id Filter restricts the list of results to variations which have a barcode with the specified ID. (optional)
     * @param  string|null $bundle_type Filter restricts the list of results to variations with the specified bundle type. (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations which have the specified category ID. (optional)
     * @param  string|null $any_category_id Filter restricts the list of results to variations which have any of the specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_category_ids Filter restricts the list of results to variations which have all specified category IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $any_characteristic_id Filter restricts the list of results to variations which have any of the specified characteristic IDs. (optional)
     * @param  string|null $all_characteristic_ids Filter restricts the list of results to variations which have all specified characteristic IDs. (optional)
     * @param  int|null $client_id Filter restricts the list of results to variations which have the specified client ID. (optional)
     * @param  string|null $any_client_id Filter restricts the list of results to variations which have any of the specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $all_client_ids Filter restricts the list of results to variations which have all specified client IDs. More than one parameter should be separated by commas. (optional)
     * @param  string|null $automatic_client_visibilities Filter restricts the list of results to variations which have any of the specified automatic client visibilities. More than one parameter should be separated by commas. (optional)
     * @param  float|null $image_has_market_id Filter restricts the list of results to variations which have an image available for the specified market ID. (optional)
     * @param  int|null $flag1 Filter restricts the list of results to variations with the specified flag one. (optional)
     * @param  int|null $flag2 Filter restricts the list of results to variations with the specified flag two. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $any_manufacturer_id Filter restricts the list of results to variations with any of the specified manufacturer IDs. (optional)
     * @param  string|null $item_type Filter restricts the list of results to variations which have the specified item type. (optional)
     * @param  float|null $market_id Filter restricts the list of results to variations which have the specified market ID. (optional)
     * @param  string|null $any_market_id Filter restricts the list of results to variations which have any of the specified market IDs. (optional)
     * @param  string|null $all_market_ids Filter restricts the list of results to variations which have all specified market IDs. (optional)
     * @param  string|null $price_between Filter restricts the list of results to variations which have a sales price between the specified minimum and maximum value. Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $price_between_by_id Filter restricts the list of results to variations where the specified sales price is between the specified minimum and maximum value. Sales price ID, Minimum and maximum value should be separated by a comma. (optional)
     * @param  string|null $any_sales_price_id Filter restricts the list of results to variations which have any of the specified sales price IDs. More than one parameter should be separated by commas. (optional)
     * @param  int|null $property_selection_id Filter restricts the list of results to variations which have the specified property selection ID. (optional)
     * @param  string|null $any_property_selection_id Filter restricts the list of results to variations which have any of the specified property selection IDs. (optional)
     * @param  string|null $all_property_selection_ids Filter restricts the list of results to variations which have all specified property selection IDs. (optional)
     * @param  string|null $has_name_in_language Filter restricts the list of results to variations which have a name in the specified language. (optional)
     * @param  string|null $created_at Filter restricts the list of results to variations which have been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to variations which have been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_created_at Filter restricts the list of results to variations whose item has been created in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $item_updated_at Filter restricts the list of results to variations whose item has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $availability_updated_at Filter restricts the list of results to variations whose availablity has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  string|null $stock_updated_at Filter restricts the list of results to variations whose stock has been updated in the specified time frame. The from and to parameter should be separated by a comma. If there is no to value, the current time is used instead. (optional)
     * @param  int|null $page The requested page of results. Default value is 1. (optional)
     * @param  int|null $items_per_page The number of results per page. Maximum value is 250. Default value is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPimVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPimVariationsGetRequest(
        $with = null,
        $sort_by = null,
        $group_by = null,
        $ids = null,
        $item_id = null,
        $item_ids = null,
        $is_active = null,
        $is_main = null,
        $is_salable = null,
        $supplier_id = null,
        $availability_ids = null,
        $has_children = null,
        $has_active_children = null,
        $attribute_id = null,
        $any_attribute_id = null,
        $all_attribute_ids = null,
        $attribute_value_id = null,
        $any_attribute_value_id = null,
        $all_attribute_value_ids = null,
        $barcode_code = null,
        $barcode_id = null,
        $bundle_type = null,
        $category_id = null,
        $any_category_id = null,
        $all_category_ids = null,
        $any_characteristic_id = null,
        $all_characteristic_ids = null,
        $client_id = null,
        $any_client_id = null,
        $all_client_ids = null,
        $automatic_client_visibilities = null,
        $image_has_market_id = null,
        $flag1 = null,
        $flag2 = null,
        $manufacturer_id = null,
        $any_manufacturer_id = null,
        $item_type = null,
        $market_id = null,
        $any_market_id = null,
        $all_market_ids = null,
        $price_between = null,
        $price_between_by_id = null,
        $any_sales_price_id = null,
        $property_selection_id = null,
        $any_property_selection_id = null,
        $all_property_selection_ids = null,
        $has_name_in_language = null,
        $created_at = null,
        $updated_at = null,
        $item_created_at = null,
        $item_updated_at = null,
        $availability_updated_at = null,
        $stock_updated_at = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restPimVariationsGet'][0]
    ): Request
    {

























































        $resourcePath = '/rest/pim/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_by,
            'groupBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_ids,
            'itemIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active,
            'isActive', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_main,
            'isMain', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_salable,
            'isSalable', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_id,
            'supplierId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $availability_ids,
            'availabilityIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_children,
            'hasChildren', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_active_children,
            'hasActiveChildren', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_id,
            'attributeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_attribute_id,
            'anyAttributeId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_attribute_ids,
            'allAttributeIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_value_id,
            'attributeValueId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_attribute_value_id,
            'anyAttributeValueId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_attribute_value_ids,
            'allAttributeValueIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $barcode_code,
            'barcodeCode', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $barcode_id,
            'barcodeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bundle_type,
            'bundleType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_category_id,
            'anyCategoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_category_ids,
            'allCategoryIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_characteristic_id,
            'anyCharacteristicId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_characteristic_ids,
            'allCharacteristicIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_id,
            'clientId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_client_id,
            'anyClientId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_client_ids,
            'allClientIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $automatic_client_visibilities,
            'automaticClientVisibilities', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_has_market_id,
            'imageHasMarketId', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $flag1,
            'flag1', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $flag2,
            'flag2', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $manufacturer_id,
            'manufacturerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_manufacturer_id,
            'anyManufacturerId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_type,
            'itemType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $market_id,
            'marketId', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_market_id,
            'anyMarketId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_market_ids,
            'allMarketIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $price_between,
            'priceBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $price_between_by_id,
            'priceBetweenById', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_sales_price_id,
            'anySalesPriceId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_selection_id,
            'propertySelectionId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_property_selection_id,
            'anyPropertySelectionId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_property_selection_ids,
            'allPropertySelectionIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_name_in_language,
            'hasNameInLanguage', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_created_at,
            'itemCreatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_updated_at,
            'itemUpdatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $availability_updated_at,
            'availabilityUpdatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stock_updated_at,
            'stockUpdatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
