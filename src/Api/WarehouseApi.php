<?php
/**
 * WarehouseApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * WarehouseApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class WarehouseApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restWarehousesLayoutsPost' => [
            'application/json',
        ],
        'restWarehousesLocationsAvailabilityWarehouseLocationIdGet' => [
            'application/json',
        ],
        'restWarehousesLocationsDelete' => [
            'application/json',
        ],
        'restWarehousesLocationsDetailsGet' => [
            'application/json',
        ],
        'restWarehousesLocationsDimensionsPost' => [
            'application/json',
        ],
        'restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete' => [
            'application/json',
        ],
        'restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet' => [
            'application/json',
        ],
        'restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut' => [
            'application/json',
        ],
        'restWarehousesLocationsGroupPut' => [
            'application/json',
        ],
        'restWarehousesLocationsLevelsPositionsPost' => [
            'application/json',
        ],
        'restWarehousesLocationsLevelsPost' => [
            'application/json',
        ],
        'restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete' => [
            'application/json',
        ],
        'restWarehousesLocationsLevelsWarehouseLocationLevelIdGet' => [
            'application/json',
        ],
        'restWarehousesLocationsLevelsWarehouseLocationLevelIdPut' => [
            'application/json',
        ],
        'restWarehousesLocationsMultipleDimensionsPost' => [
            'application/json',
        ],
        'restWarehousesLocationsPositionsPost' => [
            'application/json',
        ],
        'restWarehousesLocationsPost' => [
            'application/json',
        ],
        'restWarehousesLocationsPreviewsPost' => [
            'application/json',
        ],
        'restWarehousesLocationsStockWarehouseLocationIdGet' => [
            'application/json',
        ],
        'restWarehousesLocationsWarehouseIdLabelPost' => [
            'application/json',
        ],
        'restWarehousesLocationsWarehouseLocationIdDelete' => [
            'application/json',
        ],
        'restWarehousesLocationsWarehouseLocationIdGet' => [
            'application/json',
        ],
        'restWarehousesLocationsWarehouseLocationIdPut' => [
            'application/json',
        ],
        'restWarehousesStructureWarehouseIdGet' => [
            'application/json',
        ],
        'restWarehousesStructureWarehouseIdMovingGet' => [
            'application/json',
        ],
        'restWarehousesWarehouseIdLocationsDimensionsGet' => [
            'application/json',
        ],
        'restWarehousesWarehouseIdLocationsGet' => [
            'application/json',
        ],
        'restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet' => [
            'application/json',
        ],
        'restWarehousesWarehouseIdLocationsLevelsGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restWarehousesLayoutsPost
     *
     * Create a warehouse location layout
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLayoutsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationDimension
     */
    public function restWarehousesLayoutsPost(
        int $parent_id,
        int $warehouse_id,
        int $level,
        string $name,
        string $shortcut,
        string $separator,
        int $is_active_for_pickup_path,
        int $dimension_id,
        int $position,
        int $level_id,
        string $label,
        string $purpose_key,
        string $status_key,
        string $contentType = self::contentTypes['restWarehousesLayoutsPost'][0]
    ): \ck\Model\WarehouseLocationDimension
    {
        list($response) = $this->restWarehousesLayoutsPostWithHttpInfo($parent_id, $warehouse_id, $level, $name, $shortcut, $separator, $is_active_for_pickup_path, $dimension_id, $position, $level_id, $label, $purpose_key, $status_key, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLayoutsPostWithHttpInfo
     *
     * Create a warehouse location layout
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLayoutsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationDimension, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLayoutsPostWithHttpInfo(
        int $parent_id,
        int $warehouse_id,
        int $level,
        string $name,
        string $shortcut,
        string $separator,
        int $is_active_for_pickup_path,
        int $dimension_id,
        int $position,
        int $level_id,
        string $label,
        string $purpose_key,
        string $status_key,
        string $contentType = self::contentTypes['restWarehousesLayoutsPost'][0]
    ): array
    {
        $request = $this->restWarehousesLayoutsPostRequest($parent_id, $warehouse_id, $level, $name, $shortcut, $separator, $is_active_for_pickup_path, $dimension_id, $position, $level_id, $label, $purpose_key, $status_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationDimension' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationDimension' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationDimension', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationDimension';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationDimension',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLayoutsPostAsync
     *
     * Create a warehouse location layout
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLayoutsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLayoutsPostAsync(
        int $parent_id,
        int $warehouse_id,
        int $level,
        string $name,
        string $shortcut,
        string $separator,
        int $is_active_for_pickup_path,
        int $dimension_id,
        int $position,
        int $level_id,
        string $label,
        string $purpose_key,
        string $status_key,
        string $contentType = self::contentTypes['restWarehousesLayoutsPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLayoutsPostAsyncWithHttpInfo($parent_id, $warehouse_id, $level, $name, $shortcut, $separator, $is_active_for_pickup_path, $dimension_id, $position, $level_id, $label, $purpose_key, $status_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLayoutsPostAsyncWithHttpInfo
     *
     * Create a warehouse location layout
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLayoutsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLayoutsPostAsyncWithHttpInfo(
        $parent_id,
        $warehouse_id,
        $level,
        $name,
        $shortcut,
        $separator,
        $is_active_for_pickup_path,
        $dimension_id,
        $position,
        $level_id,
        $label,
        $purpose_key,
        $status_key,
        string $contentType = self::contentTypes['restWarehousesLayoutsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationDimension';
        $request = $this->restWarehousesLayoutsPostRequest($parent_id, $warehouse_id, $level, $name, $shortcut, $separator, $is_active_for_pickup_path, $dimension_id, $position, $level_id, $label, $purpose_key, $status_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLayoutsPost'
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLayoutsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLayoutsPostRequest(
        $parent_id,
        $warehouse_id,
        $level,
        $name,
        $shortcut,
        $separator,
        $is_active_for_pickup_path,
        $dimension_id,
        $position,
        $level_id,
        $label,
        $purpose_key,
        $status_key,
        string $contentType = self::contentTypes['restWarehousesLayoutsPost'][0]
    ): Request
    {

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $parent_id when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'level' is set
        if ($level === null || (is_array($level) && count($level) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $level when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'shortcut' is set
        if ($shortcut === null || (is_array($shortcut) && count($shortcut) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $shortcut when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'separator' is set
        if ($separator === null || (is_array($separator) && count($separator) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $separator when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'is_active_for_pickup_path' is set
        if ($is_active_for_pickup_path === null || (is_array($is_active_for_pickup_path) && count($is_active_for_pickup_path) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $is_active_for_pickup_path when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'dimension_id' is set
        if ($dimension_id === null || (is_array($dimension_id) && count($dimension_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $dimension_id when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'level_id' is set
        if ($level_id === null || (is_array($level_id) && count($level_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $level_id when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'label' is set
        if ($label === null || (is_array($label) && count($label) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $label when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'purpose_key' is set
        if ($purpose_key === null || (is_array($purpose_key) && count($purpose_key) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $purpose_key when calling restWarehousesLayoutsPost'
            );
        }

        // verify the required parameter 'status_key' is set
        if ($status_key === null || (is_array($status_key) && count($status_key) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $status_key when calling restWarehousesLayoutsPost'
            );
        }


        $resourcePath = '/rest/warehouses/layouts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $warehouse_id,
            'warehouseId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shortcut,
            'shortcut', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $separator,
            'separator', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active_for_pickup_path,
            'isActiveForPickupPath', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dimension_id,
            'dimensionId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level_id,
            'levelId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label,
            'label', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $purpose_key,
            'purposeKey', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_key,
            'statusKey', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsAvailabilityWarehouseLocationIdGet
     *
     * Get availability for storage location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restWarehousesLocationsAvailabilityWarehouseLocationIdGet(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'][0]
    ): array
    {
        list($response) = $this->restWarehousesLocationsAvailabilityWarehouseLocationIdGetWithHttpInfo($warehouse_location_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsAvailabilityWarehouseLocationIdGetWithHttpInfo
     *
     * Get availability for storage location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsAvailabilityWarehouseLocationIdGetWithHttpInfo(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsAvailabilityWarehouseLocationIdGetRequest($warehouse_location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsAvailabilityWarehouseLocationIdGetAsync
     *
     * Get availability for storage location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsAvailabilityWarehouseLocationIdGetAsync(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsAvailabilityWarehouseLocationIdGetAsyncWithHttpInfo($warehouse_location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsAvailabilityWarehouseLocationIdGetAsyncWithHttpInfo
     *
     * Get availability for storage location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsAvailabilityWarehouseLocationIdGetAsyncWithHttpInfo(
        $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restWarehousesLocationsAvailabilityWarehouseLocationIdGetRequest($warehouse_location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsAvailabilityWarehouseLocationIdGet'
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsAvailabilityWarehouseLocationIdGetRequest(
        $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsAvailabilityWarehouseLocationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_id' is set
        if ($warehouse_location_id === null || (is_array($warehouse_location_id) && count($warehouse_location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_id when calling restWarehousesLocationsAvailabilityWarehouseLocationIdGet'
            );
        }


        $resourcePath = '/rest/warehouses/locations/availability/{warehouseLocationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsDelete
     *
     * Delete multiple warehouse locations
     *
     * @param  int $warehouse_location_ids An array containing all the ID&#39;s for the warehouse locations that need to be deleted (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restWarehousesLocationsDelete(
        int $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsDelete'][0]
    ): void
    {
        $this->restWarehousesLocationsDeleteWithHttpInfo($warehouse_location_ids, $contentType);
    }

    /**
     * Operation restWarehousesLocationsDeleteWithHttpInfo
     *
     * Delete multiple warehouse locations
     *
     * @param  int $warehouse_location_ids An array containing all the ID&#39;s for the warehouse locations that need to be deleted (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsDeleteWithHttpInfo(
        int $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsDelete'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsDeleteRequest($warehouse_location_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsDeleteAsync
     *
     * Delete multiple warehouse locations
     *
     * @param  int $warehouse_location_ids An array containing all the ID&#39;s for the warehouse locations that need to be deleted (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDeleteAsync(
        int $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsDelete'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsDeleteAsyncWithHttpInfo($warehouse_location_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsDeleteAsyncWithHttpInfo
     *
     * Delete multiple warehouse locations
     *
     * @param  int $warehouse_location_ids An array containing all the ID&#39;s for the warehouse locations that need to be deleted (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDeleteAsyncWithHttpInfo(
        $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restWarehousesLocationsDeleteRequest($warehouse_location_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsDelete'
     *
     * @param  int $warehouse_location_ids An array containing all the ID&#39;s for the warehouse locations that need to be deleted (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsDeleteRequest(
        $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsDelete'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_ids' is set
        if ($warehouse_location_ids === null || (is_array($warehouse_location_ids) && count($warehouse_location_ids) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_ids when calling restWarehousesLocationsDelete'
            );
        }


        $resourcePath = '/rest/warehouses/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $warehouse_location_ids,
            'warehouseLocationIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsDetailsGet
     *
     * Get warehouse location details
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDetailsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restWarehousesLocationsDetailsGet(
        string $contentType = self::contentTypes['restWarehousesLocationsDetailsGet'][0]
    ): object
    {
        list($response) = $this->restWarehousesLocationsDetailsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsDetailsGetWithHttpInfo
     *
     * Get warehouse location details
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDetailsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsDetailsGetWithHttpInfo(
        string $contentType = self::contentTypes['restWarehousesLocationsDetailsGet'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsDetailsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsDetailsGetAsync
     *
     * Get warehouse location details
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDetailsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDetailsGetAsync(
        string $contentType = self::contentTypes['restWarehousesLocationsDetailsGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsDetailsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsDetailsGetAsyncWithHttpInfo
     *
     * Get warehouse location details
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDetailsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDetailsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restWarehousesLocationsDetailsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restWarehousesLocationsDetailsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsDetailsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDetailsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsDetailsGetRequest(
        string $contentType = self::contentTypes['restWarehousesLocationsDetailsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/warehouses/locations/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsDimensionsPost
     *
     * Create a warehouse location dimension
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationDimension
     */
    public function restWarehousesLocationsDimensionsPost(
        int $parent_id,
        int $warehouse_id,
        int $level,
        string $name,
        string $shortcut,
        string $separator,
        int $is_active_for_pickup_path,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsPost'][0]
    ): \ck\Model\WarehouseLocationDimension
    {
        list($response) = $this->restWarehousesLocationsDimensionsPostWithHttpInfo($parent_id, $warehouse_id, $level, $name, $shortcut, $separator, $is_active_for_pickup_path, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsDimensionsPostWithHttpInfo
     *
     * Create a warehouse location dimension
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationDimension, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsDimensionsPostWithHttpInfo(
        int $parent_id,
        int $warehouse_id,
        int $level,
        string $name,
        string $shortcut,
        string $separator,
        int $is_active_for_pickup_path,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsPost'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsDimensionsPostRequest($parent_id, $warehouse_id, $level, $name, $shortcut, $separator, $is_active_for_pickup_path, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationDimension' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationDimension' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationDimension', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationDimension';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationDimension',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsDimensionsPostAsync
     *
     * Create a warehouse location dimension
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDimensionsPostAsync(
        int $parent_id,
        int $warehouse_id,
        int $level,
        string $name,
        string $shortcut,
        string $separator,
        int $is_active_for_pickup_path,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsDimensionsPostAsyncWithHttpInfo($parent_id, $warehouse_id, $level, $name, $shortcut, $separator, $is_active_for_pickup_path, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsDimensionsPostAsyncWithHttpInfo
     *
     * Create a warehouse location dimension
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDimensionsPostAsyncWithHttpInfo(
        $parent_id,
        $warehouse_id,
        $level,
        $name,
        $shortcut,
        $separator,
        $is_active_for_pickup_path,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationDimension';
        $request = $this->restWarehousesLocationsDimensionsPostRequest($parent_id, $warehouse_id, $level, $name, $shortcut, $separator, $is_active_for_pickup_path, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsDimensionsPost'
     *
     * @param  int $parent_id The parent ID of the warehouse location dimension (required)
     * @param  int $warehouse_id The warehouse ID of the warehouse location dimension (required)
     * @param  int $level The level of the warehouse location dimension (required)
     * @param  string $name The name of the warehouse location dimension (required)
     * @param  string $shortcut The shortcut of the warehouse location dimension (required)
     * @param  string $separator The separator of the warehouse location dimension (required)
     * @param  int $is_active_for_pickup_path Active flag for pickup path of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsDimensionsPostRequest(
        $parent_id,
        $warehouse_id,
        $level,
        $name,
        $shortcut,
        $separator,
        $is_active_for_pickup_path,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsPost'][0]
    ): Request
    {

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $parent_id when calling restWarehousesLocationsDimensionsPost'
            );
        }

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesLocationsDimensionsPost'
            );
        }

        // verify the required parameter 'level' is set
        if ($level === null || (is_array($level) && count($level) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $level when calling restWarehousesLocationsDimensionsPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name when calling restWarehousesLocationsDimensionsPost'
            );
        }

        // verify the required parameter 'shortcut' is set
        if ($shortcut === null || (is_array($shortcut) && count($shortcut) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $shortcut when calling restWarehousesLocationsDimensionsPost'
            );
        }

        // verify the required parameter 'separator' is set
        if ($separator === null || (is_array($separator) && count($separator) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $separator when calling restWarehousesLocationsDimensionsPost'
            );
        }

        // verify the required parameter 'is_active_for_pickup_path' is set
        if ($is_active_for_pickup_path === null || (is_array($is_active_for_pickup_path) && count($is_active_for_pickup_path) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $is_active_for_pickup_path when calling restWarehousesLocationsDimensionsPost'
            );
        }


        $resourcePath = '/rest/warehouses/locations/dimensions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $warehouse_id,
            'warehouseId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shortcut,
            'shortcut', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $separator,
            'separator', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active_for_pickup_path,
            'isActiveForPickupPath', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete
     *
     * Delete a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'][0]
    ): void
    {
        $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteWithHttpInfo($warehouse_location_dimension_id, $contentType);
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteWithHttpInfo
     *
     * Delete a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteWithHttpInfo(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteRequest($warehouse_location_dimension_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteAsync
     *
     * Delete a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteAsync(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteAsyncWithHttpInfo($warehouse_location_dimension_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteAsyncWithHttpInfo
     *
     * Delete a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteAsyncWithHttpInfo(
        $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteRequest($warehouse_location_dimension_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDeleteRequest(
        $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_dimension_id' is set
        if ($warehouse_location_dimension_id === null || (is_array($warehouse_location_dimension_id) && count($warehouse_location_dimension_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_dimension_id when calling restWarehousesLocationsDimensionsWarehouseLocationDimensionIdDelete'
            );
        }


        $resourcePath = '/rest/warehouses/locations/dimensions/{warehouseLocationDimensionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_dimension_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationDimensionId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_dimension_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet
     *
     * Get a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationDimension
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'][0]
    ): \ck\Model\WarehouseLocationDimension
    {
        list($response) = $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetWithHttpInfo($warehouse_location_dimension_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetWithHttpInfo
     *
     * Get a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationDimension, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetWithHttpInfo(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetRequest($warehouse_location_dimension_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationDimension' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationDimension' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationDimension', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationDimension';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationDimension',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetAsync
     *
     * Get a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetAsync(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetAsyncWithHttpInfo($warehouse_location_dimension_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetAsyncWithHttpInfo
     *
     * Get a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetAsyncWithHttpInfo(
        $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationDimension';
        $request = $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetRequest($warehouse_location_dimension_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGetRequest(
        $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_dimension_id' is set
        if ($warehouse_location_dimension_id === null || (is_array($warehouse_location_dimension_id) && count($warehouse_location_dimension_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_dimension_id when calling restWarehousesLocationsDimensionsWarehouseLocationDimensionIdGet'
            );
        }


        $resourcePath = '/rest/warehouses/locations/dimensions/{warehouseLocationDimensionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_dimension_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationDimensionId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_dimension_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut
     *
     * Update a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationDimension
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'][0]
    ): \ck\Model\WarehouseLocationDimension
    {
        list($response) = $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutWithHttpInfo($warehouse_location_dimension_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutWithHttpInfo
     *
     * Update a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationDimension, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutWithHttpInfo(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutRequest($warehouse_location_dimension_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationDimension' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationDimension' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationDimension', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationDimension';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationDimension',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutAsync
     *
     * Update a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutAsync(
        int $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutAsyncWithHttpInfo($warehouse_location_dimension_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutAsyncWithHttpInfo
     *
     * Update a warehouse location dimension
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutAsyncWithHttpInfo(
        $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationDimension';
        $request = $this->restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutRequest($warehouse_location_dimension_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'
     *
     * @param  int $warehouse_location_dimension_id The ID of the warehouse location dimension (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPutRequest(
        $warehouse_location_dimension_id,
        string $contentType = self::contentTypes['restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_dimension_id' is set
        if ($warehouse_location_dimension_id === null || (is_array($warehouse_location_dimension_id) && count($warehouse_location_dimension_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_dimension_id when calling restWarehousesLocationsDimensionsWarehouseLocationDimensionIdPut'
            );
        }


        $resourcePath = '/rest/warehouses/locations/dimensions/{warehouseLocationDimensionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_dimension_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationDimensionId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_dimension_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsGroupPut
     *
     * Edit the purpose and status for a group of storage locations
     *
     * @param  string $purpose The purpose key value for warehouse location purposeKey field (required)
     * @param  string $status The status key value for warehouse location status field (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsGroupPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocation[]
     */
    public function restWarehousesLocationsGroupPut(
        string $purpose,
        string $status,
        string $contentType = self::contentTypes['restWarehousesLocationsGroupPut'][0]
    ): array
    {
        list($response) = $this->restWarehousesLocationsGroupPutWithHttpInfo($purpose, $status, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsGroupPutWithHttpInfo
     *
     * Edit the purpose and status for a group of storage locations
     *
     * @param  string $purpose The purpose key value for warehouse location purposeKey field (required)
     * @param  string $status The status key value for warehouse location status field (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsGroupPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsGroupPutWithHttpInfo(
        string $purpose,
        string $status,
        string $contentType = self::contentTypes['restWarehousesLocationsGroupPut'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsGroupPutRequest($purpose, $status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsGroupPutAsync
     *
     * Edit the purpose and status for a group of storage locations
     *
     * @param  string $purpose The purpose key value for warehouse location purposeKey field (required)
     * @param  string $status The status key value for warehouse location status field (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsGroupPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsGroupPutAsync(
        string $purpose,
        string $status,
        string $contentType = self::contentTypes['restWarehousesLocationsGroupPut'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsGroupPutAsyncWithHttpInfo($purpose, $status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsGroupPutAsyncWithHttpInfo
     *
     * Edit the purpose and status for a group of storage locations
     *
     * @param  string $purpose The purpose key value for warehouse location purposeKey field (required)
     * @param  string $status The status key value for warehouse location status field (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsGroupPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsGroupPutAsyncWithHttpInfo(
        $purpose,
        $status,
        string $contentType = self::contentTypes['restWarehousesLocationsGroupPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocation[]';
        $request = $this->restWarehousesLocationsGroupPutRequest($purpose, $status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsGroupPut'
     *
     * @param  string $purpose The purpose key value for warehouse location purposeKey field (required)
     * @param  string $status The status key value for warehouse location status field (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsGroupPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsGroupPutRequest(
        $purpose,
        $status,
        string $contentType = self::contentTypes['restWarehousesLocationsGroupPut'][0]
    ): Request
    {

        // verify the required parameter 'purpose' is set
        if ($purpose === null || (is_array($purpose) && count($purpose) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $purpose when calling restWarehousesLocationsGroupPut'
            );
        }

        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $status when calling restWarehousesLocationsGroupPut'
            );
        }


        $resourcePath = '/rest/warehouses/locations/group';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $purpose,
            'purpose', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsLevelsPositionsPost
     *
     * Move a warehouse location level position
     *
     * @param  int $to_move The warehouse location level ID that needs needs to be moved (required)
     * @param  int $target The warehouse location level ID that stands as position for the warehouse location level that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPositionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restWarehousesLocationsLevelsPositionsPost(
        int $to_move,
        int $target,
        string $side,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPositionsPost'][0]
    ): void
    {
        $this->restWarehousesLocationsLevelsPositionsPostWithHttpInfo($to_move, $target, $side, $contentType);
    }

    /**
     * Operation restWarehousesLocationsLevelsPositionsPostWithHttpInfo
     *
     * Move a warehouse location level position
     *
     * @param  int $to_move The warehouse location level ID that needs needs to be moved (required)
     * @param  int $target The warehouse location level ID that stands as position for the warehouse location level that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPositionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsLevelsPositionsPostWithHttpInfo(
        int $to_move,
        int $target,
        string $side,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPositionsPost'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsLevelsPositionsPostRequest($to_move, $target, $side, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsLevelsPositionsPostAsync
     *
     * Move a warehouse location level position
     *
     * @param  int $to_move The warehouse location level ID that needs needs to be moved (required)
     * @param  int $target The warehouse location level ID that stands as position for the warehouse location level that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsPositionsPostAsync(
        int $to_move,
        int $target,
        string $side,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPositionsPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsLevelsPositionsPostAsyncWithHttpInfo($to_move, $target, $side, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsLevelsPositionsPostAsyncWithHttpInfo
     *
     * Move a warehouse location level position
     *
     * @param  int $to_move The warehouse location level ID that needs needs to be moved (required)
     * @param  int $target The warehouse location level ID that stands as position for the warehouse location level that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsPositionsPostAsyncWithHttpInfo(
        $to_move,
        $target,
        $side,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPositionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restWarehousesLocationsLevelsPositionsPostRequest($to_move, $target, $side, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsLevelsPositionsPost'
     *
     * @param  int $to_move The warehouse location level ID that needs needs to be moved (required)
     * @param  int $target The warehouse location level ID that stands as position for the warehouse location level that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsLevelsPositionsPostRequest(
        $to_move,
        $target,
        $side,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPositionsPost'][0]
    ): Request
    {

        // verify the required parameter 'to_move' is set
        if ($to_move === null || (is_array($to_move) && count($to_move) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $to_move when calling restWarehousesLocationsLevelsPositionsPost'
            );
        }

        // verify the required parameter 'target' is set
        if ($target === null || (is_array($target) && count($target) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $target when calling restWarehousesLocationsLevelsPositionsPost'
            );
        }

        // verify the required parameter 'side' is set
        if ($side === null || (is_array($side) && count($side) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $side when calling restWarehousesLocationsLevelsPositionsPost'
            );
        }


        $resourcePath = '/rest/warehouses/locations/levels/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to_move,
            'toMove', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $side,
            'side', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsLevelsPost
     *
     * Create a warehouse location level
     *
     * @param  int $parent_id The parent ID of the warehouse location level (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  string $name The name of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationLevel
     */
    public function restWarehousesLocationsLevelsPost(
        int $parent_id,
        int $dimension_id,
        int $position,
        string $name,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPost'][0]
    ): \ck\Model\WarehouseLocationLevel
    {
        list($response) = $this->restWarehousesLocationsLevelsPostWithHttpInfo($parent_id, $dimension_id, $position, $name, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsLevelsPostWithHttpInfo
     *
     * Create a warehouse location level
     *
     * @param  int $parent_id The parent ID of the warehouse location level (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  string $name The name of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationLevel, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsLevelsPostWithHttpInfo(
        int $parent_id,
        int $dimension_id,
        int $position,
        string $name,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPost'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsLevelsPostRequest($parent_id, $dimension_id, $position, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationLevel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationLevel' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationLevel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationLevel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsLevelsPostAsync
     *
     * Create a warehouse location level
     *
     * @param  int $parent_id The parent ID of the warehouse location level (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  string $name The name of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsPostAsync(
        int $parent_id,
        int $dimension_id,
        int $position,
        string $name,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsLevelsPostAsyncWithHttpInfo($parent_id, $dimension_id, $position, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsLevelsPostAsyncWithHttpInfo
     *
     * Create a warehouse location level
     *
     * @param  int $parent_id The parent ID of the warehouse location level (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  string $name The name of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsPostAsyncWithHttpInfo(
        $parent_id,
        $dimension_id,
        $position,
        $name,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationLevel';
        $request = $this->restWarehousesLocationsLevelsPostRequest($parent_id, $dimension_id, $position, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsLevelsPost'
     *
     * @param  int $parent_id The parent ID of the warehouse location level (required)
     * @param  int $dimension_id The warehouse location dimension ID of the warehouse location level (required)
     * @param  int $position The position of the warehouse location level (required)
     * @param  string $name The name of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsLevelsPostRequest(
        $parent_id,
        $dimension_id,
        $position,
        $name,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsPost'][0]
    ): Request
    {

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $parent_id when calling restWarehousesLocationsLevelsPost'
            );
        }

        // verify the required parameter 'dimension_id' is set
        if ($dimension_id === null || (is_array($dimension_id) && count($dimension_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $dimension_id when calling restWarehousesLocationsLevelsPost'
            );
        }

        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position when calling restWarehousesLocationsLevelsPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name when calling restWarehousesLocationsLevelsPost'
            );
        }


        $resourcePath = '/rest/warehouses/locations/levels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dimension_id,
            'dimensionId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete
     *
     * Delete a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'][0]
    ): void
    {
        $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteWithHttpInfo($warehouse_location_level_id, $contentType);
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteWithHttpInfo
     *
     * Delete a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteWithHttpInfo(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteRequest($warehouse_location_level_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteAsync
     *
     * Delete a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteAsync(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteAsyncWithHttpInfo($warehouse_location_level_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteAsyncWithHttpInfo
     *
     * Delete a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteAsyncWithHttpInfo(
        $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteRequest($warehouse_location_level_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdDeleteRequest(
        $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_level_id' is set
        if ($warehouse_location_level_id === null || (is_array($warehouse_location_level_id) && count($warehouse_location_level_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_level_id when calling restWarehousesLocationsLevelsWarehouseLocationLevelIdDelete'
            );
        }


        $resourcePath = '/rest/warehouses/locations/levels/{warehouseLocationLevelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_level_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationLevelId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_level_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdGet
     *
     * Get a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationLevel
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdGet(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'][0]
    ): \ck\Model\WarehouseLocationLevel
    {
        list($response) = $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdGetWithHttpInfo($warehouse_location_level_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdGetWithHttpInfo
     *
     * Get a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationLevel, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdGetWithHttpInfo(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdGetRequest($warehouse_location_level_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationLevel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationLevel' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationLevel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationLevel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdGetAsync
     *
     * Get a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdGetAsync(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdGetAsyncWithHttpInfo($warehouse_location_level_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdGetAsyncWithHttpInfo
     *
     * Get a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdGetAsyncWithHttpInfo(
        $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationLevel';
        $request = $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdGetRequest($warehouse_location_level_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdGetRequest(
        $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_level_id' is set
        if ($warehouse_location_level_id === null || (is_array($warehouse_location_level_id) && count($warehouse_location_level_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_level_id when calling restWarehousesLocationsLevelsWarehouseLocationLevelIdGet'
            );
        }


        $resourcePath = '/rest/warehouses/locations/levels/{warehouseLocationLevelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_level_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationLevelId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_level_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdPut
     *
     * Update a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationLevel
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdPut(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'][0]
    ): \ck\Model\WarehouseLocationLevel
    {
        list($response) = $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdPutWithHttpInfo($warehouse_location_level_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdPutWithHttpInfo
     *
     * Update a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationLevel, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdPutWithHttpInfo(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdPutRequest($warehouse_location_level_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationLevel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationLevel' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationLevel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationLevel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdPutAsync
     *
     * Update a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdPutAsync(
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdPutAsyncWithHttpInfo($warehouse_location_level_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsLevelsWarehouseLocationLevelIdPutAsyncWithHttpInfo
     *
     * Update a warehouse location level
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdPutAsyncWithHttpInfo(
        $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationLevel';
        $request = $this->restWarehousesLocationsLevelsWarehouseLocationLevelIdPutRequest($warehouse_location_level_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'
     *
     * @param  int $warehouse_location_level_id The ID of the warehouse location level (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsLevelsWarehouseLocationLevelIdPutRequest(
        $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_level_id' is set
        if ($warehouse_location_level_id === null || (is_array($warehouse_location_level_id) && count($warehouse_location_level_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_level_id when calling restWarehousesLocationsLevelsWarehouseLocationLevelIdPut'
            );
        }


        $resourcePath = '/rest/warehouses/locations/levels/{warehouseLocationLevelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_level_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationLevelId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_level_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsMultipleDimensionsPost
     *
     * Create multiple warehouse location dimensions
     *
     * @param  int $dimensions The dimensions array that contains data for creating multiple dimensions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationDimension[]
     */
    public function restWarehousesLocationsMultipleDimensionsPost(
        int $dimensions,
        string $contentType = self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'][0]
    ): array
    {
        list($response) = $this->restWarehousesLocationsMultipleDimensionsPostWithHttpInfo($dimensions, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsMultipleDimensionsPostWithHttpInfo
     *
     * Create multiple warehouse location dimensions
     *
     * @param  int $dimensions The dimensions array that contains data for creating multiple dimensions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationDimension[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsMultipleDimensionsPostWithHttpInfo(
        int $dimensions,
        string $contentType = self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsMultipleDimensionsPostRequest($dimensions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationDimension[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationDimension[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationDimension[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationDimension[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationDimension[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsMultipleDimensionsPostAsync
     *
     * Create multiple warehouse location dimensions
     *
     * @param  int $dimensions The dimensions array that contains data for creating multiple dimensions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsMultipleDimensionsPostAsync(
        int $dimensions,
        string $contentType = self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsMultipleDimensionsPostAsyncWithHttpInfo($dimensions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsMultipleDimensionsPostAsyncWithHttpInfo
     *
     * Create multiple warehouse location dimensions
     *
     * @param  int $dimensions The dimensions array that contains data for creating multiple dimensions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsMultipleDimensionsPostAsyncWithHttpInfo(
        $dimensions,
        string $contentType = self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationDimension[]';
        $request = $this->restWarehousesLocationsMultipleDimensionsPostRequest($dimensions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsMultipleDimensionsPost'
     *
     * @param  int $dimensions The dimensions array that contains data for creating multiple dimensions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsMultipleDimensionsPostRequest(
        $dimensions,
        string $contentType = self::contentTypes['restWarehousesLocationsMultipleDimensionsPost'][0]
    ): Request
    {

        // verify the required parameter 'dimensions' is set
        if ($dimensions === null || (is_array($dimensions) && count($dimensions) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $dimensions when calling restWarehousesLocationsMultipleDimensionsPost'
            );
        }


        $resourcePath = '/rest/warehouses/locations/multiple_dimensions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dimensions,
            'dimensions', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsPositionsPost
     *
     * Move a warehouse location position
     *
     * @param  int $to_move The warehouse location ID that needs needs to be moved (required)
     * @param  int $target The warehouse location ID that stands as position for the warehouse location that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPositionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restWarehousesLocationsPositionsPost(
        int $to_move,
        int $target,
        string $side,
        string $contentType = self::contentTypes['restWarehousesLocationsPositionsPost'][0]
    ): void
    {
        $this->restWarehousesLocationsPositionsPostWithHttpInfo($to_move, $target, $side, $contentType);
    }

    /**
     * Operation restWarehousesLocationsPositionsPostWithHttpInfo
     *
     * Move a warehouse location position
     *
     * @param  int $to_move The warehouse location ID that needs needs to be moved (required)
     * @param  int $target The warehouse location ID that stands as position for the warehouse location that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPositionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsPositionsPostWithHttpInfo(
        int $to_move,
        int $target,
        string $side,
        string $contentType = self::contentTypes['restWarehousesLocationsPositionsPost'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsPositionsPostRequest($to_move, $target, $side, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsPositionsPostAsync
     *
     * Move a warehouse location position
     *
     * @param  int $to_move The warehouse location ID that needs needs to be moved (required)
     * @param  int $target The warehouse location ID that stands as position for the warehouse location that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsPositionsPostAsync(
        int $to_move,
        int $target,
        string $side,
        string $contentType = self::contentTypes['restWarehousesLocationsPositionsPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsPositionsPostAsyncWithHttpInfo($to_move, $target, $side, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsPositionsPostAsyncWithHttpInfo
     *
     * Move a warehouse location position
     *
     * @param  int $to_move The warehouse location ID that needs needs to be moved (required)
     * @param  int $target The warehouse location ID that stands as position for the warehouse location that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsPositionsPostAsyncWithHttpInfo(
        $to_move,
        $target,
        $side,
        string $contentType = self::contentTypes['restWarehousesLocationsPositionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restWarehousesLocationsPositionsPostRequest($to_move, $target, $side, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsPositionsPost'
     *
     * @param  int $to_move The warehouse location ID that needs needs to be moved (required)
     * @param  int $target The warehouse location ID that stands as position for the warehouse location that needs to be moved (required)
     * @param  string $side The actual position from the left or right side of target (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsPositionsPostRequest(
        $to_move,
        $target,
        $side,
        string $contentType = self::contentTypes['restWarehousesLocationsPositionsPost'][0]
    ): Request
    {

        // verify the required parameter 'to_move' is set
        if ($to_move === null || (is_array($to_move) && count($to_move) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $to_move when calling restWarehousesLocationsPositionsPost'
            );
        }

        // verify the required parameter 'target' is set
        if ($target === null || (is_array($target) && count($target) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $target when calling restWarehousesLocationsPositionsPost'
            );
        }

        // verify the required parameter 'side' is set
        if ($side === null || (is_array($side) && count($side) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $side when calling restWarehousesLocationsPositionsPost'
            );
        }


        $resourcePath = '/rest/warehouses/locations/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to_move,
            'toMove', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $side,
            'side', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsPost
     *
     * Create a warehouse location
     *
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  int $position The position of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocation
     */
    public function restWarehousesLocationsPost(
        int $level_id,
        string $label,
        string $purpose_key,
        string $status_key,
        int $position,
        string $contentType = self::contentTypes['restWarehousesLocationsPost'][0]
    ): \ck\Model\WarehouseLocation
    {
        list($response) = $this->restWarehousesLocationsPostWithHttpInfo($level_id, $label, $purpose_key, $status_key, $position, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsPostWithHttpInfo
     *
     * Create a warehouse location
     *
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  int $position The position of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsPostWithHttpInfo(
        int $level_id,
        string $label,
        string $purpose_key,
        string $status_key,
        int $position,
        string $contentType = self::contentTypes['restWarehousesLocationsPost'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsPostRequest($level_id, $label, $purpose_key, $status_key, $position, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsPostAsync
     *
     * Create a warehouse location
     *
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  int $position The position of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsPostAsync(
        int $level_id,
        string $label,
        string $purpose_key,
        string $status_key,
        int $position,
        string $contentType = self::contentTypes['restWarehousesLocationsPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsPostAsyncWithHttpInfo($level_id, $label, $purpose_key, $status_key, $position, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsPostAsyncWithHttpInfo
     *
     * Create a warehouse location
     *
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  int $position The position of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsPostAsyncWithHttpInfo(
        $level_id,
        $label,
        $purpose_key,
        $status_key,
        $position,
        string $contentType = self::contentTypes['restWarehousesLocationsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocation';
        $request = $this->restWarehousesLocationsPostRequest($level_id, $label, $purpose_key, $status_key, $position, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsPost'
     *
     * @param  int $level_id The warehouse location level ID of the warehouse location (required)
     * @param  string $label The label of the warehouse location (required)
     * @param  string $purpose_key The location type key of the warehouse location (required)
     * @param  string $status_key The location status key of the warehouse location (required)
     * @param  int $position The position of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsPostRequest(
        $level_id,
        $label,
        $purpose_key,
        $status_key,
        $position,
        string $contentType = self::contentTypes['restWarehousesLocationsPost'][0]
    ): Request
    {

        // verify the required parameter 'level_id' is set
        if ($level_id === null || (is_array($level_id) && count($level_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $level_id when calling restWarehousesLocationsPost'
            );
        }

        // verify the required parameter 'label' is set
        if ($label === null || (is_array($label) && count($label) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $label when calling restWarehousesLocationsPost'
            );
        }

        // verify the required parameter 'purpose_key' is set
        if ($purpose_key === null || (is_array($purpose_key) && count($purpose_key) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $purpose_key when calling restWarehousesLocationsPost'
            );
        }

        // verify the required parameter 'status_key' is set
        if ($status_key === null || (is_array($status_key) && count($status_key) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $status_key when calling restWarehousesLocationsPost'
            );
        }

        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position when calling restWarehousesLocationsPost'
            );
        }


        $resourcePath = '/rest/warehouses/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level_id,
            'levelId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label,
            'label', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $purpose_key,
            'purposeKey', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_key,
            'statusKey', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsPreviewsPost
     *
     * Generate warehouse location preview and saves it
     *
     * @param  int $dimensions The warehouse location dimensions used by the generator (required)
     * @param  int $storage_location_data The warehouse location data used by the generator (required)
     * @param  int $level_data The warehouse location level data used by the generator (required)
     * @param  int $save The save parameter that triggers the preview method or the process save method (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPreviewsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restWarehousesLocationsPreviewsPost(
        int $dimensions,
        int $storage_location_data,
        int $level_data,
        int $save,
        string $contentType = self::contentTypes['restWarehousesLocationsPreviewsPost'][0]
    ): object
    {
        list($response) = $this->restWarehousesLocationsPreviewsPostWithHttpInfo($dimensions, $storage_location_data, $level_data, $save, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsPreviewsPostWithHttpInfo
     *
     * Generate warehouse location preview and saves it
     *
     * @param  int $dimensions The warehouse location dimensions used by the generator (required)
     * @param  int $storage_location_data The warehouse location data used by the generator (required)
     * @param  int $level_data The warehouse location level data used by the generator (required)
     * @param  int $save The save parameter that triggers the preview method or the process save method (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPreviewsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsPreviewsPostWithHttpInfo(
        int $dimensions,
        int $storage_location_data,
        int $level_data,
        int $save,
        string $contentType = self::contentTypes['restWarehousesLocationsPreviewsPost'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsPreviewsPostRequest($dimensions, $storage_location_data, $level_data, $save, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsPreviewsPostAsync
     *
     * Generate warehouse location preview and saves it
     *
     * @param  int $dimensions The warehouse location dimensions used by the generator (required)
     * @param  int $storage_location_data The warehouse location data used by the generator (required)
     * @param  int $level_data The warehouse location level data used by the generator (required)
     * @param  int $save The save parameter that triggers the preview method or the process save method (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPreviewsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsPreviewsPostAsync(
        int $dimensions,
        int $storage_location_data,
        int $level_data,
        int $save,
        string $contentType = self::contentTypes['restWarehousesLocationsPreviewsPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsPreviewsPostAsyncWithHttpInfo($dimensions, $storage_location_data, $level_data, $save, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsPreviewsPostAsyncWithHttpInfo
     *
     * Generate warehouse location preview and saves it
     *
     * @param  int $dimensions The warehouse location dimensions used by the generator (required)
     * @param  int $storage_location_data The warehouse location data used by the generator (required)
     * @param  int $level_data The warehouse location level data used by the generator (required)
     * @param  int $save The save parameter that triggers the preview method or the process save method (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPreviewsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsPreviewsPostAsyncWithHttpInfo(
        $dimensions,
        $storage_location_data,
        $level_data,
        $save,
        string $contentType = self::contentTypes['restWarehousesLocationsPreviewsPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restWarehousesLocationsPreviewsPostRequest($dimensions, $storage_location_data, $level_data, $save, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsPreviewsPost'
     *
     * @param  int $dimensions The warehouse location dimensions used by the generator (required)
     * @param  int $storage_location_data The warehouse location data used by the generator (required)
     * @param  int $level_data The warehouse location level data used by the generator (required)
     * @param  int $save The save parameter that triggers the preview method or the process save method (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsPreviewsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsPreviewsPostRequest(
        $dimensions,
        $storage_location_data,
        $level_data,
        $save,
        string $contentType = self::contentTypes['restWarehousesLocationsPreviewsPost'][0]
    ): Request
    {

        // verify the required parameter 'dimensions' is set
        if ($dimensions === null || (is_array($dimensions) && count($dimensions) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $dimensions when calling restWarehousesLocationsPreviewsPost'
            );
        }

        // verify the required parameter 'storage_location_data' is set
        if ($storage_location_data === null || (is_array($storage_location_data) && count($storage_location_data) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storage_location_data when calling restWarehousesLocationsPreviewsPost'
            );
        }

        // verify the required parameter 'level_data' is set
        if ($level_data === null || (is_array($level_data) && count($level_data) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $level_data when calling restWarehousesLocationsPreviewsPost'
            );
        }

        // verify the required parameter 'save' is set
        if ($save === null || (is_array($save) && count($save) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $save when calling restWarehousesLocationsPreviewsPost'
            );
        }


        $resourcePath = '/rest/warehouses/locations/previews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dimensions,
            'dimensions', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $storage_location_data,
            'storageLocationData', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level_data,
            'levelData', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $save,
            'save', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsStockWarehouseLocationIdGet
     *
     * List warehouse locations stock
     *
     * @param  int $warehouse_location_id The ID of the warehouse (required)
     * @param  int $warehouse_location_id2 warehouse_location_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response
     */
    public function restWarehousesLocationsStockWarehouseLocationIdGet(
        int $warehouse_location_id,
        int $warehouse_location_id2,
        string $contentType = self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'][0]
    ): \ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response
    {
        list($response) = $this->restWarehousesLocationsStockWarehouseLocationIdGetWithHttpInfo($warehouse_location_id, $warehouse_location_id2, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsStockWarehouseLocationIdGetWithHttpInfo
     *
     * List warehouse locations stock
     *
     * @param  int $warehouse_location_id The ID of the warehouse (required)
     * @param  int $warehouse_location_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsStockWarehouseLocationIdGetWithHttpInfo(
        int $warehouse_location_id,
        int $warehouse_location_id2,
        string $contentType = self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsStockWarehouseLocationIdGetRequest($warehouse_location_id, $warehouse_location_id2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsStockWarehouseLocationIdGetAsync
     *
     * List warehouse locations stock
     *
     * @param  int $warehouse_location_id The ID of the warehouse (required)
     * @param  int $warehouse_location_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsStockWarehouseLocationIdGetAsync(
        int $warehouse_location_id,
        int $warehouse_location_id2,
        string $contentType = self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsStockWarehouseLocationIdGetAsyncWithHttpInfo($warehouse_location_id, $warehouse_location_id2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsStockWarehouseLocationIdGetAsyncWithHttpInfo
     *
     * List warehouse locations stock
     *
     * @param  int $warehouse_location_id The ID of the warehouse (required)
     * @param  int $warehouse_location_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsStockWarehouseLocationIdGetAsyncWithHttpInfo(
        $warehouse_location_id,
        $warehouse_location_id2,
        string $contentType = self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response';
        $request = $this->restWarehousesLocationsStockWarehouseLocationIdGetRequest($warehouse_location_id, $warehouse_location_id2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsStockWarehouseLocationIdGet'
     *
     * @param  int $warehouse_location_id The ID of the warehouse (required)
     * @param  int $warehouse_location_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsStockWarehouseLocationIdGetRequest(
        $warehouse_location_id,
        $warehouse_location_id2,
        string $contentType = self::contentTypes['restWarehousesLocationsStockWarehouseLocationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_id' is set
        if ($warehouse_location_id === null || (is_array($warehouse_location_id) && count($warehouse_location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_id when calling restWarehousesLocationsStockWarehouseLocationIdGet'
            );
        }

        // verify the required parameter 'warehouse_location_id2' is set
        if ($warehouse_location_id2 === null || (is_array($warehouse_location_id2) && count($warehouse_location_id2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_id2 when calling restWarehousesLocationsStockWarehouseLocationIdGet'
            );
        }


        $resourcePath = '/rest/warehouses/locations/stock/{warehouseLocationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $warehouse_location_id,
            '$warehouseLocationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($warehouse_location_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_id2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsWarehouseIdLabelPost
     *
     * Generate the warehouse location label
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $warehouse_location_ids A string with all warehouse location ID&#39;s for which a label needs to be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restWarehousesLocationsWarehouseIdLabelPost(
        int $warehouse_id,
        string $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'][0]
    ): object
    {
        list($response) = $this->restWarehousesLocationsWarehouseIdLabelPostWithHttpInfo($warehouse_id, $warehouse_location_ids, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsWarehouseIdLabelPostWithHttpInfo
     *
     * Generate the warehouse location label
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $warehouse_location_ids A string with all warehouse location ID&#39;s for which a label needs to be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsWarehouseIdLabelPostWithHttpInfo(
        int $warehouse_id,
        string $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsWarehouseIdLabelPostRequest($warehouse_id, $warehouse_location_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsWarehouseIdLabelPostAsync
     *
     * Generate the warehouse location label
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $warehouse_location_ids A string with all warehouse location ID&#39;s for which a label needs to be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsWarehouseIdLabelPostAsync(
        int $warehouse_id,
        string $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsWarehouseIdLabelPostAsyncWithHttpInfo($warehouse_id, $warehouse_location_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsWarehouseIdLabelPostAsyncWithHttpInfo
     *
     * Generate the warehouse location label
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $warehouse_location_ids A string with all warehouse location ID&#39;s for which a label needs to be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsWarehouseIdLabelPostAsyncWithHttpInfo(
        $warehouse_id,
        $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restWarehousesLocationsWarehouseIdLabelPostRequest($warehouse_id, $warehouse_location_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsWarehouseIdLabelPost'
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $warehouse_location_ids A string with all warehouse location ID&#39;s for which a label needs to be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsWarehouseIdLabelPostRequest(
        $warehouse_id,
        $warehouse_location_ids,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseIdLabelPost'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesLocationsWarehouseIdLabelPost'
            );
        }

        // verify the required parameter 'warehouse_location_ids' is set
        if ($warehouse_location_ids === null || (is_array($warehouse_location_ids) && count($warehouse_location_ids) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_ids when calling restWarehousesLocationsWarehouseIdLabelPost'
            );
        }


        $resourcePath = '/rest/warehouses/locations/{warehouseId}/label';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $warehouse_location_ids,
            'warehouseLocationIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdDelete
     *
     * Delete a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restWarehousesLocationsWarehouseLocationIdDelete(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'][0]
    ): void
    {
        $this->restWarehousesLocationsWarehouseLocationIdDeleteWithHttpInfo($warehouse_location_id, $contentType);
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdDeleteWithHttpInfo
     *
     * Delete a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsWarehouseLocationIdDeleteWithHttpInfo(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsWarehouseLocationIdDeleteRequest($warehouse_location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdDeleteAsync
     *
     * Delete a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsWarehouseLocationIdDeleteAsync(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsWarehouseLocationIdDeleteAsyncWithHttpInfo($warehouse_location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdDeleteAsyncWithHttpInfo
     *
     * Delete a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsWarehouseLocationIdDeleteAsyncWithHttpInfo(
        $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restWarehousesLocationsWarehouseLocationIdDeleteRequest($warehouse_location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsWarehouseLocationIdDelete'
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsWarehouseLocationIdDeleteRequest(
        $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_id' is set
        if ($warehouse_location_id === null || (is_array($warehouse_location_id) && count($warehouse_location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_id when calling restWarehousesLocationsWarehouseLocationIdDelete'
            );
        }


        $resourcePath = '/rest/warehouses/locations/{warehouseLocationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdGet
     *
     * Get a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocation
     */
    public function restWarehousesLocationsWarehouseLocationIdGet(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'][0]
    ): \ck\Model\WarehouseLocation
    {
        list($response) = $this->restWarehousesLocationsWarehouseLocationIdGetWithHttpInfo($warehouse_location_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdGetWithHttpInfo
     *
     * Get a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsWarehouseLocationIdGetWithHttpInfo(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsWarehouseLocationIdGetRequest($warehouse_location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdGetAsync
     *
     * Get a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsWarehouseLocationIdGetAsync(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsWarehouseLocationIdGetAsyncWithHttpInfo($warehouse_location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdGetAsyncWithHttpInfo
     *
     * Get a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsWarehouseLocationIdGetAsyncWithHttpInfo(
        $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocation';
        $request = $this->restWarehousesLocationsWarehouseLocationIdGetRequest($warehouse_location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsWarehouseLocationIdGet'
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsWarehouseLocationIdGetRequest(
        $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_id' is set
        if ($warehouse_location_id === null || (is_array($warehouse_location_id) && count($warehouse_location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_id when calling restWarehousesLocationsWarehouseLocationIdGet'
            );
        }


        $resourcePath = '/rest/warehouses/locations/{warehouseLocationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdPut
     *
     * Update a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocation
     */
    public function restWarehousesLocationsWarehouseLocationIdPut(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'][0]
    ): \ck\Model\WarehouseLocation
    {
        list($response) = $this->restWarehousesLocationsWarehouseLocationIdPutWithHttpInfo($warehouse_location_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdPutWithHttpInfo
     *
     * Update a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesLocationsWarehouseLocationIdPutWithHttpInfo(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'][0]
    ): array
    {
        $request = $this->restWarehousesLocationsWarehouseLocationIdPutRequest($warehouse_location_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdPutAsync
     *
     * Update a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsWarehouseLocationIdPutAsync(
        int $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesLocationsWarehouseLocationIdPutAsyncWithHttpInfo($warehouse_location_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesLocationsWarehouseLocationIdPutAsyncWithHttpInfo
     *
     * Update a warehouse location
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesLocationsWarehouseLocationIdPutAsyncWithHttpInfo(
        $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocation';
        $request = $this->restWarehousesLocationsWarehouseLocationIdPutRequest($warehouse_location_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesLocationsWarehouseLocationIdPut'
     *
     * @param  int $warehouse_location_id The ID of the warehouse location (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesLocationsWarehouseLocationIdPutRequest(
        $warehouse_location_id,
        string $contentType = self::contentTypes['restWarehousesLocationsWarehouseLocationIdPut'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_location_id' is set
        if ($warehouse_location_id === null || (is_array($warehouse_location_id) && count($warehouse_location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_id when calling restWarehousesLocationsWarehouseLocationIdPut'
            );
        }


        $resourcePath = '/rest/warehouses/locations/{warehouseLocationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesStructureWarehouseIdGet
     *
     * Get a warehouse location structure
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restWarehousesStructureWarehouseIdGet(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdGet'][0]
    ): object
    {
        list($response) = $this->restWarehousesStructureWarehouseIdGetWithHttpInfo($warehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesStructureWarehouseIdGetWithHttpInfo
     *
     * Get a warehouse location structure
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesStructureWarehouseIdGetWithHttpInfo(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdGet'][0]
    ): array
    {
        $request = $this->restWarehousesStructureWarehouseIdGetRequest($warehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesStructureWarehouseIdGetAsync
     *
     * Get a warehouse location structure
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesStructureWarehouseIdGetAsync(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesStructureWarehouseIdGetAsyncWithHttpInfo($warehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesStructureWarehouseIdGetAsyncWithHttpInfo
     *
     * Get a warehouse location structure
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesStructureWarehouseIdGetAsyncWithHttpInfo(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restWarehousesStructureWarehouseIdGetRequest($warehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesStructureWarehouseIdGet'
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesStructureWarehouseIdGetRequest(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesStructureWarehouseIdGet'
            );
        }


        $resourcePath = '/rest/warehouses/structure/{warehouseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesStructureWarehouseIdMovingGet
     *
     * Get a warehouse location structure moving
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restWarehousesStructureWarehouseIdMovingGet(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'][0]
    ): object
    {
        list($response) = $this->restWarehousesStructureWarehouseIdMovingGetWithHttpInfo($warehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesStructureWarehouseIdMovingGetWithHttpInfo
     *
     * Get a warehouse location structure moving
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesStructureWarehouseIdMovingGetWithHttpInfo(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'][0]
    ): array
    {
        $request = $this->restWarehousesStructureWarehouseIdMovingGetRequest($warehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesStructureWarehouseIdMovingGetAsync
     *
     * Get a warehouse location structure moving
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesStructureWarehouseIdMovingGetAsync(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesStructureWarehouseIdMovingGetAsyncWithHttpInfo($warehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesStructureWarehouseIdMovingGetAsyncWithHttpInfo
     *
     * Get a warehouse location structure moving
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesStructureWarehouseIdMovingGetAsyncWithHttpInfo(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restWarehousesStructureWarehouseIdMovingGetRequest($warehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesStructureWarehouseIdMovingGet'
     *
     * @param  int $warehouse_id The actual warehouse ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesStructureWarehouseIdMovingGetRequest(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesStructureWarehouseIdMovingGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesStructureWarehouseIdMovingGet'
            );
        }


        $resourcePath = '/rest/warehouses/structure/{warehouseId}/moving';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsDimensionsGet
     *
     * List warehouse location dimensions
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationDimension
     */
    public function restWarehousesWarehouseIdLocationsDimensionsGet(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'][0]
    ): \ck\Model\WarehouseLocationDimension
    {
        list($response) = $this->restWarehousesWarehouseIdLocationsDimensionsGetWithHttpInfo($warehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsDimensionsGetWithHttpInfo
     *
     * List warehouse location dimensions
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationDimension, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesWarehouseIdLocationsDimensionsGetWithHttpInfo(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'][0]
    ): array
    {
        $request = $this->restWarehousesWarehouseIdLocationsDimensionsGetRequest($warehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationDimension' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationDimension' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationDimension', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationDimension';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationDimension',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsDimensionsGetAsync
     *
     * List warehouse location dimensions
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesWarehouseIdLocationsDimensionsGetAsync(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesWarehouseIdLocationsDimensionsGetAsyncWithHttpInfo($warehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsDimensionsGetAsyncWithHttpInfo
     *
     * List warehouse location dimensions
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesWarehouseIdLocationsDimensionsGetAsyncWithHttpInfo(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationDimension';
        $request = $this->restWarehousesWarehouseIdLocationsDimensionsGetRequest($warehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesWarehouseIdLocationsDimensionsGet'
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesWarehouseIdLocationsDimensionsGetRequest(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsDimensionsGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesWarehouseIdLocationsDimensionsGet'
            );
        }


        $resourcePath = '/rest/warehouses/{warehouseId}/locations/dimensions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsGet
     *
     * List warehouse locations
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response
     */
    public function restWarehousesWarehouseIdLocationsGet(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsGet'][0]
    ): \ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response
    {
        list($response) = $this->restWarehousesWarehouseIdLocationsGetWithHttpInfo($warehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsGetWithHttpInfo
     *
     * List warehouse locations
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesWarehouseIdLocationsGetWithHttpInfo(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsGet'][0]
    ): array
    {
        $request = $this->restWarehousesWarehouseIdLocationsGetRequest($warehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsGetAsync
     *
     * List warehouse locations
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesWarehouseIdLocationsGetAsync(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesWarehouseIdLocationsGetAsyncWithHttpInfo($warehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsGetAsyncWithHttpInfo
     *
     * List warehouse locations
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesWarehouseIdLocationsGetAsyncWithHttpInfo(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestWarehousesLocationsStockWarehouseLocationIdGet200Response';
        $request = $this->restWarehousesWarehouseIdLocationsGetRequest($warehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesWarehouseIdLocationsGet'
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesWarehouseIdLocationsGetRequest(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesWarehouseIdLocationsGet'
            );
        }


        $resourcePath = '/rest/warehouses/{warehouseId}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet
     *
     * List warehouse locations by levelId
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  int $level_id The ID of the warehouse location level (required)
     * @param  int $warehouse_location_level_id warehouse_location_level_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet(
        int $warehouse_id,
        int $level_id,
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'][0]
    ): object
    {
        list($response) = $this->restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetWithHttpInfo($warehouse_id, $level_id, $warehouse_location_level_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetWithHttpInfo
     *
     * List warehouse locations by levelId
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  int $level_id The ID of the warehouse location level (required)
     * @param  int $warehouse_location_level_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetWithHttpInfo(
        int $warehouse_id,
        int $level_id,
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'][0]
    ): array
    {
        $request = $this->restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetRequest($warehouse_id, $level_id, $warehouse_location_level_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetAsync
     *
     * List warehouse locations by levelId
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  int $level_id The ID of the warehouse location level (required)
     * @param  int $warehouse_location_level_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetAsync(
        int $warehouse_id,
        int $level_id,
        int $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetAsyncWithHttpInfo($warehouse_id, $level_id, $warehouse_location_level_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetAsyncWithHttpInfo
     *
     * List warehouse locations by levelId
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  int $level_id The ID of the warehouse location level (required)
     * @param  int $warehouse_location_level_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetAsyncWithHttpInfo(
        $warehouse_id,
        $level_id,
        $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetRequest($warehouse_id, $level_id, $warehouse_location_level_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  int $level_id The ID of the warehouse location level (required)
     * @param  int $warehouse_location_level_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGetRequest(
        $warehouse_id,
        $level_id,
        $warehouse_location_level_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'
            );
        }

        // verify the required parameter 'level_id' is set
        if ($level_id === null || (is_array($level_id) && count($level_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $level_id when calling restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'
            );
        }

        // verify the required parameter 'warehouse_location_level_id' is set
        if ($warehouse_location_level_id === null || (is_array($warehouse_location_level_id) && count($warehouse_location_level_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_location_level_id when calling restWarehousesWarehouseIdLocationsLevelWarehouseLocationLevelIdGet'
            );
        }


        $resourcePath = '/rest/warehouses/{warehouseId}/locations/level/{warehouseLocationLevelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level_id,
            'levelId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }
        // path params
        if ($warehouse_location_level_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseLocationLevelId' . '}',
                ObjectSerializer::toPathValue($warehouse_location_level_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsLevelsGet
     *
     * List warehouse location levels
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\WarehouseLocationLevel[]
     */
    public function restWarehousesWarehouseIdLocationsLevelsGet(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'][0]
    ): array
    {
        list($response) = $this->restWarehousesWarehouseIdLocationsLevelsGetWithHttpInfo($warehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsLevelsGetWithHttpInfo
     *
     * List warehouse location levels
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\WarehouseLocationLevel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restWarehousesWarehouseIdLocationsLevelsGetWithHttpInfo(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'][0]
    ): array
    {
        $request = $this->restWarehousesWarehouseIdLocationsLevelsGetRequest($warehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\WarehouseLocationLevel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\WarehouseLocationLevel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\WarehouseLocationLevel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\WarehouseLocationLevel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\WarehouseLocationLevel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsLevelsGetAsync
     *
     * List warehouse location levels
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesWarehouseIdLocationsLevelsGetAsync(
        int $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'][0]
    ): PromiseInterface
    {
        return $this->restWarehousesWarehouseIdLocationsLevelsGetAsyncWithHttpInfo($warehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restWarehousesWarehouseIdLocationsLevelsGetAsyncWithHttpInfo
     *
     * List warehouse location levels
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restWarehousesWarehouseIdLocationsLevelsGetAsyncWithHttpInfo(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\WarehouseLocationLevel[]';
        $request = $this->restWarehousesWarehouseIdLocationsLevelsGetRequest($warehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restWarehousesWarehouseIdLocationsLevelsGet'
     *
     * @param  int $warehouse_id The ID of the warehouse (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restWarehousesWarehouseIdLocationsLevelsGetRequest(
        $warehouse_id,
        string $contentType = self::contentTypes['restWarehousesWarehouseIdLocationsLevelsGet'][0]
    ): Request
    {

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restWarehousesWarehouseIdLocationsLevelsGet'
            );
        }


        $resourcePath = '/rest/warehouses/{warehouseId}/locations/levels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
